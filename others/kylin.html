layout: false
---
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><!-- <meta name="baidu-site-verification" content="707024a76f8f40b549f07f478abab237"/> -->
<title>kylin</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="kylin"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-01-02T19:57+0800"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="shortcut icon" href="http://blog.com/css/favicon.ico" /> <link rel="stylesheet" type="text/css" href="./css/site.css" />


</head>
<body><!-- <div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare"><a class="bds_tsina"></a><span class="bds_more"></span><a class="shareCount"></a></div> --><!-- Place this tag where you want the +1 button to render --><!-- <g:plusone annotation="inline"></g:plusone> -->

<div id="preamble">

</div>

<div id="content">
<h1 class="title">kylin</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 kylin</a>
<ul>
<li><a href="#sec-1-1">1.1 share</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1 atomic</a></li>
<li><a href="#sec-1-1-2">1.1.2 spinlock</a></li>
<li><a href="#sec-1-1-3">1.1.3 cycle</a></li>
<li><a href="#sec-1-1-4">1.1.4 support</a></li>
<li><a href="#sec-1-1-5">1.1.5 futex</a>
<ul>
<li><a href="#sec-1-1-5-1">1.1.5.1 sema</a></li>
<li><a href="#sec-1-1-5-2">1.1.5.2 cond</a></li>
<li><a href="#sec-1-1-5-3">1.1.5.3 event</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2 kylin</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1 Async</a></li>
<li><a href="#sec-1-2-2">1.2.2 ThreadPool</a>
<ul>
<li><a href="#sec-1-2-2-1">1.2.2.1 Overview</a></li>
<li><a href="#sec-1-2-2-2">1.2.2.2 How Thread Works</a></li>
<li><a href="#sec-1-2-2-3">1.2.2.3 AddWorker &amp; DelWorker</a></li>
<li><a href="#sec-1-2-2-4">1.2.2.4 QueueJob &amp; CancelJob</a></li>
</ul>
</li>
<li><a href="#sec-1-2-3">1.2.3 TranBuf</a>
<ul>
<li><a href="#sec-1-2-3-1">1.2.3.1 Overview</a></li>
<li><a href="#sec-1-2-3-2">1.2.3.2 Create</a></li>
<li><a href="#sec-1-2-3-3">1.2.3.3 AllocOnce</a></li>
<li><a href="#sec-1-2-3-4">1.2.3.4 GetHandle</a></li>
<li><a href="#sec-1-2-3-5">1.2.3.5 AddRef</a></li>
<li><a href="#sec-1-2-3-6">1.2.3.6 Destroy</a></li>
<li><a href="#sec-1-2-3-7">1.2.3.7 Allocate</a></li>
<li><a href="#sec-1-2-3-8">1.2.3.8 Free</a></li>
</ul>
</li>
<li><a href="#sec-1-2-4">1.2.4 BufHandle</a>
<ul>
<li><a href="#sec-1-2-4-1">1.2.4.1 OverView</a></li>
<li><a href="#sec-1-2-4-2">1.2.4.2 SetTranBuf</a></li>
<li><a href="#sec-1-2-4-3">1.2.4.3 DoAllocate</a></li>
<li><a href="#sec-1-2-4-4">1.2.4.4 DoAllocateCanFail</a></li>
<li><a href="#sec-1-2-4-5">1.2.4.5 _DoAddRef</a></li>
<li><a href="#sec-1-2-4-6">1.2.4.6 _DoFree</a></li>
<li><a href="#sec-1-2-4-7">1.2.4.7 AllocateBig</a></li>
<li><a href="#sec-1-2-4-8">1.2.4.8 AllocateCanFail</a></li>
<li><a href="#sec-1-2-4-9">1.2.4.9 AllocForBuf</a></li>
<li><a href="#sec-1-2-4-10">1.2.4.10 Allocate</a></li>
<li><a href="#sec-1-2-4-11">1.2.4.11 ChainFree</a></li>
<li><a href="#sec-1-2-4-12">1.2.4.12 CloneAndTerminate</a></li>
</ul>
</li>
<li><a href="#sec-1-2-5">1.2.5 Kylin</a></li>
<li><a href="#sec-1-2-6">1.2.6 ExecMan</a>
<ul>
<li><a href="#sec-1-2-6-1">1.2.6.1 Overview</a></li>
<li><a href="#sec-1-2-6-2">1.2.6.2 Start &amp; Stop</a></li>
<li><a href="#sec-1-2-6-3">1.2.6.3 QueueExec</a></li>
<li><a href="#sec-1-2-6-4">1.2.6.4 Timer</a></li>
<li><a href="#sec-1-2-6-5">1.2.6.5 Example</a></li>
</ul>
</li>
<li><a href="#sec-1-2-7">1.2.7 DiskMan</a>
<ul>
<li><a href="#sec-1-2-7-1">1.2.7.1 Overview</a></li>
<li><a href="#sec-1-2-7-2">1.2.7.2 Start &amp; Stop</a></li>
<li><a href="#sec-1-2-7-3">1.2.7.3 Associate &amp; Deassociate</a></li>
<li><a href="#sec-1-2-7-4">1.2.7.4 Read &amp; Write</a></li>
<li><a href="#sec-1-2-7-5">1.2.7.5 Example</a></li>
</ul>
</li>
<li><a href="#sec-1-2-8">1.2.8 NetworkMan</a>
<ul>
<li><a href="#sec-1-2-8-1">1.2.8.1 Overview</a></li>
<li><a href="#sec-1-2-8-2">1.2.8.2 Start &amp; Stop</a></li>
<li><a href="#sec-1-2-8-3">1.2.8.3 Associate &amp; Deassociate</a></li>
<li><a href="#sec-1-2-8-4">1.2.8.4 Listen</a></li>
<li><a href="#sec-1-2-8-5">1.2.8.5 Connect</a></li>
<li><a href="#sec-1-2-8-6">1.2.8.6 Monitor</a></li>
<li><a href="#sec-1-2-8-7">1.2.8.7 Delay</a></li>
<li><a href="#sec-1-2-8-8">1.2.8.8 Read &amp; Write</a></li>
<li><a href="#sec-1-2-8-9">1.2.8.9 SocketState</a></li>
</ul>
</li>
<li><a href="#sec-1-2-9">1.2.9 EPoller</a>
<ul>
<li><a href="#sec-1-2-9-1">1.2.9.1 Overview</a></li>
<li><a href="#sec-1-2-9-2">1.2.9.2 Create &amp; Close</a></li>
<li><a href="#sec-1-2-9-3">1.2.9.3 Associate &amp; Deassociate</a></li>
<li><a href="#sec-1-2-9-4">1.2.9.4 DoConnect</a></li>
<li><a href="#sec-1-2-9-5">1.2.9.5 Delay &amp; CancalDelay</a></li>
<li><a href="#sec-1-2-9-6">1.2.9.6 DoWithDelayed &amp; DoWithError</a></li>
<li><a href="#sec-1-2-9-7">1.2.9.7 Read &amp; Write</a></li>
<li><a href="#sec-1-2-9-8">1.2.9.8 NofityClient</a></li>
<li><a href="#sec-1-2-9-9">1.2.9.9 Run</a></li>
</ul>
</li>
<li><a href="#sec-1-2-10">1.2.10 Socket</a>
<ul>
<li><a href="#sec-1-2-10-1">1.2.10.1 Overview</a></li>
<li><a href="#sec-1-2-10-2">1.2.10.2 Create</a></li>
<li><a href="#sec-1-2-10-3">1.2.10.3 Close</a></li>
<li><a href="#sec-1-2-10-4">1.2.10.4 Shutdown</a></li>
<li><a href="#sec-1-2-10-5">1.2.10.5 Listen</a></li>
<li><a href="#sec-1-2-10-6">1.2.10.6 Connect</a></li>
<li><a href="#sec-1-2-10-7">1.2.10.7 Read &amp; Write</a></li>
<li><a href="#sec-1-2-10-8">1.2.10.8 OnCompletion</a></li>
<li><a href="#sec-1-2-10-9">1.2.10.9 Summary</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3 demo</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1 echo</a>
<ul>
<li><a href="#sec-1-3-1-1">1.3.1.1 client.cc</a></li>
<li><a href="#sec-1-3-1-2">1.3.1.2 server.cc</a></li>
</ul>
</li>
<li><a href="#sec-1-3-2">1.3.2 file-request</a>
<ul>
<li><a href="#sec-1-3-2-1">1.3.2.1 client.cc</a></li>
<li><a href="#sec-1-3-2-2">1.3.2.2 server.cc</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> kylin</h2>
<div class="outline-text-2" id="text-1">


<p>
kylin是baidu in-house的异步编程框架，提供CPU，Network以及Disk异步操作接口，并且内置许多常用编程组件包括定时器和内存池等。
</p>
<p>
相关材料
</p><ul>
<li>异步编程_百度文库 : <a href="http://wenku.baidu.com/view/6fa262f67c1cfad6195fa74e.html">http://wenku.baidu.com/view/6fa262f67c1cfad6195fa74e.html</a>
</li>
<li>三谈火车票系统_新浪轻博客 : <a href="http://qing.blog.sina.com.cn/tj/85c4105033000ab2.html">http://qing.blog.sina.com.cn/tj/85c4105033000ab2.html</a>
</li>
<li>SEDA: An Architecture for Well-Conditioned, Scalable Internet Services <a href="http://www.eecs.harvard.edu/~mdw/papers/seda-sosp01.pdf">http://www.eecs.harvard.edu/~mdw/papers/seda-sosp01.pdf</a>
</li>
<li>Why Threads Are a Bad Idea <a href="http://www.stanford.edu/class/cs240/readings/threads-bad-usenix96.pdf">http://www.stanford.edu/class/cs240/readings/threads-bad-usenix96.pdf</a>
</li>
</ul>



</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> share</h3>
<div class="outline-text-3" id="text-1-1">

<p>公共组件代码
</p>

</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> atomic</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>最主要实现了atomic add/swap/cas三个操作。
</p>


<pre class="src src-C++">// return old value
static inline int atomic_add(volatile int *count, int add) {
    __asm__ __volatile__(
        <span class="org-string">"lock xadd %0, (%1);"</span>
        : <span class="org-string">"=a"</span>(add)
        : <span class="org-string">"r"</span>(count), <span class="org-string">"a"</span>(add)
        : <span class="org-string">"memory"</span>);
    return add;
}

// return old value
static inline int atomic_swap(volatile void *lockword, int value) {
    __asm__ __volatile__(
        <span class="org-string">"lock xchg %0, (%1);"</span>
        : <span class="org-string">"=a"</span>(value)
        : <span class="org-string">"r"</span>(lockword), <span class="org-string">"a"</span>(value)
        : <span class="org-string">"memory"</span>);
    return value;
}

// return old value
// &#35821;&#20041;&#26159;&#36825;&#26679;&#30340;
// &#22914;&#26524;*lockword==comperand,&#37027;&#20040;*lockword=exchange
// &#21542;&#21017;&#19981;&#36827;&#34892;&#20219;&#20309;&#25805;&#20316;
// &#36820;&#22238;&#21407;&#22987;&#30340;*lockword

// &#23545;&#20110;cmpxchg x y&#30340;&#35821;&#20041;&#26159;&#36825;&#26679;&#30340;
// &#22914;&#26524;y==%%eax,&#37027;&#20040;x-&gt;y.&#21542;&#21017;&#19981;&#21464;&#12290;&#28982;&#21518;y(&#21407;&#22987;)-&gt;%%eax
static inline int atomic_comp_swap(volatile void *lockword,
                                   int exchange,
                                   int comperand)
{
    __asm__ __volatile__(
        <span class="org-string">"lock cmpxchg %1, (%2)"</span>
        :<span class="org-string">"=a"</span>(comperand)
        :<span class="org-string">"d"</span>(exchange), <span class="org-string">"r"</span>(lockword), <span class="org-string">"a"</span>(comperand));
    return comperand;
}
</pre>

<p>
然后再上面封装了一系列原子操作。封装的一系列原子操作还是比较好理解的。
</p>


<pre class="src src-C++">#define AtomicGetValue(x)    (atomic_comp_swap(&amp;(x), 0, 0))
#define AtomicSetValue(x, v)    (atomic_swap(&amp;(x), (v)))
#define AtomicSetValueIf(x, v, ifn)(atomic_comp_swap(&amp;(x), (v), ifn))
#define AtomicDec(c)    (atomic_add(&amp;(c), -1) - 1)
#define AtomicInc(c)    (atomic_add(&amp;(c), 1) + 1)
</pre>


</div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> spinlock</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>spinlock直接使用atomic提供的原子操作来实现，理解起来倒不是很麻烦
</p>


<pre class="src src-C++">static inline void spin_lock(volatile int *lock) {
    int l;
    int i = 10;
    int id = thread_getid();
    //l==0&#30340;&#35805;&#35828;&#26126;&#21407;&#26469;lock==0&#28982;&#21518;&#34987;&#32622;&#20026;id
    //l==id&#30340;&#35805;&#35828;&#26126;&#21407;&#26469;lock==id&#37027;&#20040;&#23601;&#19981;&#24517;&#22312;&#36827;&#34892;&#21152;&#38145;&#25805;&#20316;
    for (l=atomic_comp_swap(lock, id, 0);
         l!=0 &amp;&amp; l!=id;
         l=atomic_comp_swap(lock, id, 0)
         ) {
        if (i --) {
            nop();
        }
        else {
            // &#36827;&#34892;10&#27425;nop&#20043;&#21518;&#22914;&#26524;&#27809;&#26377;&#24471;&#21040;&#38145;&#30340;&#35805;
            // &#37027;&#20040;&#23601;&#30452;&#25509;relinquish CPU
            // #define thread_yield sched_yield
            i = 10;
            thread_yield();
        }
    }
}

// &#36820;&#22238;&#20540;&#21487;&#20197;&#30693;&#36947;&#20043;&#21069;lock&#26159;&#21542;&#38145;&#22312;&#33258;&#24049;&#36825;&#37324;
// &#22914;&#26524;&#20026;false&#30340;&#35805;&#34920;&#31034;&#33258;&#24049;&#24182;&#27809;&#26377;&#38145;
static inline bool spin_unlock(volatile int *lock) {
    int id = thread_getid();
    return id == atomic_comp_swap(lock, 0, id);
}

static inline bool spin_trylock(volatile int *lock) {
    int id = thread_getid();
    int owner = atomic_comp_swap(lock, id, 0);
    return (owner==0 || owner==id);
}
</pre>


<p>
在spinlock.h下面有一个token实现。token语义非常简单，如果token==0的话那么这个令牌没有被任何人获得，
如果token!=0的话，那么令牌被token标记的对象获取了。token可以是pid,也可以是tid.
</p>


<pre class="src src-C++">static inline int token_acquire(volatile int *token, int id) {
    return atomic_comp_swap(token, id, 0);
}

static inline int token_release(volatile int *token, int id) {
    return atomic_comp_swap(token, 0, id);
}

static inline int token_transfer(volatile int *token, int oldid, int newid) {
    return atomic_comp_swap(token, newid, oldid);
}

static inline int token_set(volatile int *token, int id) {
    return atomic_comp_swap(token, id, *token);
}
</pre>


</div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> cycle</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>提供开销更小的计时器，使用读取CPU的time stamp counter.这个内容表示自计算机启动以来的CPU运行周期。
</p>


<pre class="src src-C++">static inline uint64 rdtsc() {
    unsigned int lo, hi;
    /* We cannot use <span class="org-string">"=A"</span>, since this would use %rax on x86_64 */
    __asm__ __volatile__ (
        <span class="org-string">"rdtsc"</span>
        : <span class="org-string">"=a"</span> (lo), <span class="org-string">"=d"</span> (hi));
    return (uint64)hi &lt;&lt; 32 | lo;
}
</pre>

<p>
得到周期之后我们必须转换称为时间(s)。周期转换称为时间就是除CPU的主频。得到CPU主频的话没有什么特别好的办法，
一种简单的方法是通过等待1s然后得到tsc差。对于Linux操作系统的话可以通过读取proc文件系统获得
</p>


<pre class="example">[zhangyan@tc-cm-et18.tc.baidu.com]$ cat /proc/cpuinfo
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 12
model name      : Intel(R) Xeon(R) CPU           E5620  @ 2.40GHz
stepping        : 2
cpu MHz         : 2400.186
cache size      : 256 KB
physical id     : 0
siblings        : 16
core id         : 0
cpu cores       : 16
fpu             : yes
fpu_exception   : yes
cpuid level     : 11
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm syscall nx lm pni monitor ds_cpl est tm2 cx16 xtpr
bogomips        : 4803.76
clflush size    : 64
cache_alignment : 64
address sizes   : 40 bits physical, 48 bits virtual
power management:
</pre>


</div>

</div>

<div id="outline-container-1-1-4" class="outline-4">
<h4 id="sec-1-1-4"><span class="section-number-4">1.1.4</span> support</h4>
<div class="outline-text-4" id="text-1-1-4">

<p>从这里面我们可以学习到如何进行系统调用，阅读一下&lt;asm/unistd.h&gt;可以找到系统调用号，然后使用syscall来发起。
</p>


<pre class="src src-C++">#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;cstdio&gt;
int main() {
    printf(<span class="org-string">"%lu\n"</span>,syscall(__NR_gettid));
    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-1-1-5" class="outline-4">
<h4 id="sec-1-1-5"><span class="section-number-4">1.1.5</span> futex</h4>
<div class="outline-text-4" id="text-1-1-5">

<p>关于futex的话可以看看下面这些链接
</p><ul>
<li><a href="http://en.wikipedia.org/wiki/Futex">http://en.wikipedia.org/wiki/Futex</a>
</li>
<li><a href="http://linux.die.net/man/2/futex">http://linux.die.net/man/2/futex</a>
</li>
<li><a href="http://blog.csdn.net/Javadino/article/details/2891385">http://blog.csdn.net/Javadino/article/details/2891385</a>
</li>
<li><a href="http://blog.csdn.net/Javadino/article/details/2891388">http://blog.csdn.net/Javadino/article/details/2891388</a>
</li>
<li><a href="http://blog.csdn.net/Javadino/article/details/2891399">http://blog.csdn.net/Javadino/article/details/2891399</a>
</li>
<li><a href="http://people.redhat.com/drepper/futex.pdf">http://people.redhat.com/drepper/futex.pdf</a>
</li>
</ul>

<p>尤其是最后一篇文章可以好好看看，讲到了关于如何使用futex.futex使用需要用户态和内核态的配合，用户态处理一些uncontented case,
而对于contented case的话交给内核态处理。在实际应用上发现大部分情况都是uncontented case都可以在用户态解决而不用陷入内核态。
如果想要深入了解的话，看看pthread里面同步组件的实现。
</p>
<p>
这里我们简单地介绍一下kylin里面使用futex实现的功能，先看看futex结构
</p>


<pre class="src src-C++">struct futex {
    volatile int lock; // futex shared address
    volatile int count;
};
</pre>



</div>

<div id="outline-container-1-1-5-1" class="outline-5">
<h5 id="sec-1-1-5-1"><span class="section-number-5">1.1.5.1</span> sema</h5>
<div class="outline-text-5" id="text-1-1-5-1">

<p>可以认为是操作系统里面的PV实现.count就是资源数目，lock始终==0.理解起来并不会很麻烦。
</p>


<pre class="src src-C++">static inline int futex_sema_down(struct futex* pf, struct timespec* timeout, bool interruptable) {
    // &#39318;&#20808;&#22312;&#29992;&#25143;&#24577;&#23581;&#35797;&#21462;&#36164;&#28304;
    // &#22914;&#26524;n&gt;0&#30340;&#35805;&#65292;&#35828;&#26126;&#36164;&#28304;OK,&#37027;&#20040;&#23601;&#19981;&#38656;&#35201;&#38519;&#20837;&#20869;&#26680;&#24577;&#36827;&#34892;wait.
    int n = atomic_add(&amp;pf-&gt;count, -1);
    if (n &lt;= 0) {
  retry:
        if (0 == sys_futex(&amp;pf-&gt;lock, FUTEX_WAIT, 0, timeout)) {
            return 0;
        }
        switch (errno) {
            case ETIMEDOUT:
                atomic_add(&amp;pf-&gt;count, 1);
                return ETIMEDOUT;
            case EINTR:
                if (!interruptable)
                    goto retry;
                atomic_add(&amp;pf-&gt;count, 1);
                return EINTR;
            default:
                RaiseError(IMPOSSIBLE__Can_not_lock_in_futex_sema_down);
        }
    }
    return 0;
}
static inline int futex_sema_up(struct futex* pf) {
    int retry;
    // &#39318;&#20808;&#22312;&#29992;&#25143;&#24577;&#37322;&#25918;&#36164;&#28304;
    // &#22914;&#26524;n&lt;0&#30340;&#35805;&#65292;&#35828;&#26126;&#23384;&#22312;&#31561;&#24453;&#36164;&#28304;&#30340;waiters,&#25105;&#20204;&#24517;&#39035;&#38519;&#20837;&#20869;&#26680;&#24577;wakeup.
    int n = atomic_add(&amp;pf-&gt;count, 1);
    if (n &lt; 0) {
        retry = 10;
        // &#36825;&#20010;&#22320;&#26041;&#20889;&#24471;&#38750;&#24120;&#20180;&#32454;&#38656;&#35201;&#37325;&#35797;
        while (1 != (n=sys_futex(&amp;pf-&gt;lock, FUTEX_WAKE, 1, NULL))) {
            /* it means the downer decreases the count but not yet start waiting
             *   --- may be interrupted near the retry label in the above function;
             * so we have to wait and retry.
             */
            if (retry --) {
                nop();
            }
            else {
                retry = 10;
                thread_yield();
            }
        }
        return n;
    }
    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-1-1-5-2" class="outline-5">
<h5 id="sec-1-1-5-2"><span class="section-number-5">1.1.5.2</span> cond</h5>
<div class="outline-text-5" id="text-1-1-5-2">

<p>这里cond和pthread_cond是有差别的，这里的cond没有和任何mutex相关。kylin这里认为count==0的时候，那么condition才被满足。
</p>


<pre class="src src-C++">static inline int futex_cond_wait(struct futex* pf, struct timespec* timeout, bool interruptable) {
    /* I dont know whether it is a bug of linux kernel.
     * Sometimes, sys_futex(.., FUTEX_WAIT, ..) returns 0, but the condition is not satisfied.
     * So we have to check the condition again after return.
     */
    while (0 &lt; AtomicGetValue(pf-&gt;count)) {
        sys_futex(&amp;pf-&gt;lock, FUTEX_WAIT, 0, timeout);
        switch (errno) {
            case ETIMEDOUT:
                return ETIMEDOUT;
            case EINTR:
                if (interruptable) {
                    return EINTR;
                }
            default:
                break;
        }
    }
    return 0;
}

static inline int futex_cond_signal(struct futex* pf) {
    int n = atomic_add(&amp;pf-&gt;count, -1);
    if (1 == n) {
        pf-&gt;lock = 1; // &#19968;&#26086;&#35302;&#21457;&#20043;&#21518;&#65292;&#37027;&#20040;&#23601;&#19981;&#33021;&#22815;&#20877;&#36827;&#34892;wait&#20102;&#12290;
        mfence_c();
        return sys_futex(&amp;pf-&gt;lock, FUTEX_WAKE, 65535, NULL);// I hope 65535 is enough to wake up all
    }
    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-1-1-5-3" class="outline-5">
<h5 id="sec-1-1-5-3"><span class="section-number-5">1.1.5.3</span> event</h5>
<div class="outline-text-5" id="text-1-1-5-3">

<p>这里的event名字取得也相当的奇怪。这里count实际上有两个状态，&gt;=0以及&lt;0(LARGE_ENOUGH_NEGATIVE).对于count&gt;=0的状态时候，
可以认为当前是没有signaled的需要wait，如果count为&lt;0(LARGE_ENOUGH_NEGATIVE)的时候是有signal的状态的不需要wait。
</p>


<pre class="src src-C++">static inline int futex_event_wait(struct futex* pf, struct timespec* timeout, bool interruptable) {
    // &#22914;&#26524;&#19981;&#26159;signaled&#29366;&#24577;&#30340;&#35805;
    int n = atomic_add(&amp;pf-&gt;count, 1);
    if (0 &lt;= n) {
  retry:
        if (0 == sys_futex(&amp;pf-&gt;lock, FUTEX_WAIT, 0, timeout))
            return 0;

        switch (errno) {
            case ETIMEDOUT:
                atomic_add(&amp;pf-&gt;count, -1);
                return ETIMEDOUT;
            case EINTR:
                if (!interruptable)
                    goto retry;
                atomic_add(&amp;pf-&gt;count, -1);
                return EINTR;
            default:
                RaiseError(IMPOSSIBLE__Can_not_lock_in_futex_sema_down);
        }
    }
    else {  // else signaled
        AtomicSetValue(pf-&gt;count, LARGE_ENOUGH_NEGATIVE);
    }
    return 0;
}

static inline int futex_event_signal(struct futex* pf, bool reset) {
    int m, n, retry;
    // &#30475;&#30475;&#24403;&#21069;&#26159;&#21542;signaled
    // &#22914;&#26524;&#27809;&#26377;signal&#30340;&#35805;&#65292;&#37027;&#20040;&#38656;&#35201;wakeup&#36825;&#20123;waiters.
    n = AtomicSetValue(pf-&gt;count, reset ? 0 : LARGE_ENOUGH_NEGATIVE);
    if (0 &lt; n) {
        retry = 10;
        m = n;
        do {
            n -= sys_futex(&amp;pf-&gt;lock, FUTEX_WAKE, n, NULL);
            if (0 == n)
                return m;
            if (retry --) {
                nop();
            }
            else {
                retry = 10;
                thread_yield();
            }
        } while (1);
    }
    return 0;
}

static inline void futex_event_reset(struct futex* pf) {
    int n, retry = 10;
    do {
        n = AtomicSetValueIf(pf-&gt;count, 0, LARGE_ENOUGH_NEGATIVE);
        if (0&lt;=n || LARGE_ENOUGH_NEGATIVE==n) {
            return;
        }
        if (retry --) {
            nop();
        }
        else {
            retry = 10;
            thread_yield();
        }
    } while (1);
}
</pre>


</div>
</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> kylin</h3>
<div class="outline-text-3" id="text-1-2">

<p>异步框架代码
</p>

</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> Async</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>kylin对于用户来说首先需要了解的概念就在Async.h文件里面，主要是下面两个类
</p>


<pre class="src src-C++">typedef void (*JOB_PROC)(Job*);

// &#23545;&#20110;Job&#36825;&#20010;&#20869;&#23481;&#25105;&#20204;&#31245;&#21518;&#22312;ThreadPool&#37096;&#20998;&#20250;&#26377;&#35814;&#32454;&#20998;&#26512;
struct Job {
    DLINK link; // &#20351;&#29992;link&#30340;&#35805;&#21487;&#20197;&#23558;Job&#22312;JobQ&#20013;&#20018;&#32852;&#36215;&#26469;&#21487;&#20197;&#24456;&#26041;&#20415;&#22320;&#21462;&#28040;
    JOB_PROC fProc; //&#32447;&#31243;&#27744;&#37324;&#38754;&#21253;&#21547;JobQ,&#27599;&#21462;&#19968;&#20010;Job&#20986;&#26469;&#20043;&#21518;&#23601;&#25191;&#34892;fProc.
};

class CAsyncClient;
struct AsyncContext : Job {
    APF_ERROR nErrCode; // &#21457;&#36215;&#35843;&#29992;&#20043;&#21518;&#36820;&#22238;&#30340;error_code
    int nAction; // &#21457;&#36215;&#20160;&#20040;&#35843;&#29992;
    CAsyncClient *pClient; // &#24212;&#35813;&#20351;&#29992;&#20160;&#20040;client&#26469;&#22788;&#29702;
};

class CAsyncClient
{
protected:
    // m_nId&#20165;&#20165;&#26159;&#19968;&#20010;&#32534;&#21495;&#65292;&#27599;&#27425;&#21019;&#24314;&#19968;&#20010;AsyncClient&#37117;&#20250;&#20840;&#23616;+1
    // m_nHostId&#38750;&#24120;&#37325;&#35201;&#65292;&#20351;&#29992;&#36825;&#20010;&#21487;&#20197;&#23558;Job&#25511;&#21046;&#20002;&#21040;&#21738;&#20010;&#32447;&#31243;&#25191;&#34892;
    int m_nId, m_nHostId;
    volatile int m_nRef;
    CAsyncClient(CAsyncClient* pHost);
    CAsyncClient();
    virtual ~CAsyncClient();
public:
    int GetId() const { return m_nId; }
    int GetAsyncId() const { return m_nHostId; }
    int GetHostThreadId() const;
    bool IsInHostThread() const;
    void SetHost(CAsyncClient* pHost);
    virtual int AddRef() {
        return AtomicInc(m_nRef);
    }
    virtual int Release() {
        return AtomicDec(m_nRef);
    }
    virtual int GetRef() {
        return AtomicGetValue(m_nRef);
    }
    virtual void OnCompletion(AsyncContext* pCtx) = 0; // &#29992;&#25143;&#38656;&#35201;&#37325;&#20889;&#36825;&#20010;&#36807;&#31243;
};
</pre>

<p>
对于用户来说使用过程大致是这样的：
</p><ul>
<li>创建一个CAsyncClient client实例.当然是我们自己需要继承CAsyncClient重写自己的类。
</li>
<li>创建一个AsyncContext ctx(或者是集成AsyncContext).然后将ctx和client绑定。
</li>
<li>发起调用op，传入这个ctx，为了方便理解包装成为Task(op,ctx)放入线程池。可能会设置nAction字段。
</li>
<li>线程池取出Task,结合ctx调用op.将op返回值放入APF_ERROR里面。
</li>
<li>然后根据ctx关联的client,调用client的OnCompletion方法。
</li>
<li>调用OnCompletion方法的话会根据ctx里面的标记，可以直接在工作线程调用，也可以丢入CPU线程调用。
</li>
</ul>

<p>可以看到在实现时候，最好一个client就绑定几个相关的ctx最方便了。这里有一个地方需要特别关注就是引用计数。因为C++本身没有GC实现，所以我们必须自己来管理内存分配和释放。
因为client可以一次多个调用，而在OnCompletion里面根本不知道谁先完成谁后完成，也就不能够确定释放责任了。通过引用计数可以很好地解决这个问题。
如果我们直接继承CAsyncClient的话，内部是有引用计数实现的，非常方便我们只需要如何适当地使用就OK了。关于如何适当使用，谢谢sunxiao同学在这里的建议。
</p><ul>
<li>一旦发起一次异步调用，那么首先AddRef().当然需要确保这个调用内部没有帮助我们AddRef.
</li>
<li>我们不需要显示地DecRef(),因为这个事情在线程池fProc里面调用了Release.
</li>
</ul>


</div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> ThreadPool</h4>
<div class="outline-text-4" id="text-1-2-2">


</div>

<div id="outline-container-1-2-2-1" class="outline-5">
<h5 id="sec-1-2-2-1"><span class="section-number-5">1.2.2.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-2-2-1">

<p>线程池很简单，取出一个Job出来执行就多了。但是为了更好地理解kylin有必要看看线程池接口/实现。
</p>


<pre class="src src-C++">typedef void (*THREAD_INIT_PROC)(int type, int id); // id&#34920;&#31034;&#36825;&#20010;&#32447;&#31243;&#30340;&#36923;&#36753;&#32534;&#21495;

class CThreadPool
{
    bool m_bShareQ; // &#26159;&#21542;&#25152;&#26377;&#32447;&#31243;&#20849;&#20139;&#19968;&#20010;Q
    int m_nWorkers, m_nMaxWorkers; // &#24403;&#21069;&#32447;&#31243;&#25968;&#21644;&#26368;&#22823;&#32447;&#31243;&#25968;
    volatile int m_nJobs; // &#24403;&#21069;&#26377;&#22810;&#23569;&#20010;Jobs
    thread_t *m_hWorkerThreads; // &#27599;&#20010;&#32447;&#31243;&#30340;thread&#32467;&#26500;
    WorkerContext *m_pContexts; // &#27599;&#20010;&#32447;&#31243;&#30340;context
    int m_nType; // &#20160;&#20040;&#31867;&#22411;&#32447;&#31243;&#27744;,TT_EXEC,TT_NETWORK,TT_DISK
    THREAD_INIT_PROC m_fInit; // &#32447;&#31243;&#21021;&#22987;&#21270;&#22238;&#35843;&#20989;&#25968;

    int _AddWorker(int nAdd); // &#22686;&#21152;&#22810;&#23569;&#20010;&#24037;&#20316;&#32447;&#31243;
    int _DelWorker(int nDel, bool bFinal); // &#21462;&#28040;&#22810;&#23569;&#20010;&#24037;&#20316;&#32447;&#31243;
  public:
    CThreadPool(int type, int nMaxWorkers, bool bShareQ);
    virtual ~CThreadPool();
    int Start(int nWorkers, THREAD_INIT_PROC fInit=NULL);
    void Stop();
    void QueueJob(Job* pJob, int nWhich);
    void QueueEmergentJob(Job* pJob, int nWhich);
    bool CancelJob(Job* pJob, int nWhich);
};
</pre>

<p>
对于线程池部分的话我们比较关心这么几件事情：
</p><ul>
<li>如何增加删除线程的
</li>
<li>线程是如何进行工作的
</li>
<li>如何往线程里面增加取消任务
</li>
</ul>


</div>

</div>

<div id="outline-container-1-2-2-2" class="outline-5">
<h5 id="sec-1-2-2-2"><span class="section-number-5">1.2.2.2</span> How Thread Works</h5>
<div class="outline-text-5" id="text-1-2-2-2">

<p>了解线程是怎么工作的，可以看看线程执行的函数是怎么定义的
</p>


<pre class="src src-C++">static void*
WorkerProc(void* pData)
{
    WorkerContext* pCtx = (WorkerContext*)pData;
    JobQ* pJobQ = pCtx-&gt;pJobQ;
    Job* pJob;

    TRACE4(<span class="org-string">"%s worker#%d started...\n"</span>, ThreadType2Str(pCtx-&gt;type), pCtx-&gt;id);
    pCtx-&gt;thread_id = thread_getid();
    if (pCtx-&gt;fInit) { // &#22914;&#26524;&#26377;&#21021;&#22987;&#21270;&#20989;&#25968;&#30340;&#35805;&#37027;&#20040;&#25191;&#34892;&#21021;&#22987;&#21270;&#20989;&#25968;
        pCtx-&gt;fInit(pCtx-&gt;type, pCtx-&gt;id);
    }
    while (1) {
        pJob = pJobQ-&gt;pop_front(); // &#27599;&#27425;&#24471;&#21040;&#19968;&#20010;Job
        ASSERT_NOT_EQUAL((Job*)NULL, pJob);
        if (pJob-&gt;fProc != 0) { // &#22914;&#26524;&#26159;&#26222;&#36890;Job&#30340;&#35805;&#37027;&#20040;&#26159;&#35843;&#29992;&#37324;&#38754;&#30340;Job::fProc&#36807;&#31243;
            pCtx-&gt;bDoing = true;
            pJob-&gt;fProc(pJob);
            pCtx-&gt;bDoing = false;
        }
        else { // &#21542;&#21017;&#26159;&#25511;&#21046;Job&#65292;&#20027;&#35201;&#26159;&#29992;&#20110;&#32467;&#26463;&#32447;&#31243;&#20351;&#29992;&#30340;
            ControlJob* pCtl = (ControlJob*)pJob;
            if (!pCtl-&gt;fProc(pCtl, pCtx)) {
                break;
            }
        }
    }
    TRACE4(<span class="org-string">"%s worker#%d stopped.\n"</span>, ThreadType2Str(pCtx-&gt;type), pCtx-&gt;id);
    return NULL;
}
</pre>


<p>
普通的Job会在每个Man里面单独提到，我们看看控制Job是怎么定义的。在ThreadPool里面就有一个TermianationJob.
</p>


<pre class="src src-C++">struct TerminationJob : ControlJob {
    int id;
};

static bool
TerminateWorker(ControlJob* pCtl, WorkerContext* pCtx)
{
    TerminationJob* pT = (TerminationJob*)pCtl;
    if (pT-&gt;id!=-1 &amp;&amp; pT-&gt;id!=pCtx-&gt;id) { // &#22914;&#26524;&#22240;&#20026;&#20849;&#20139;&#38431;&#21015;&#32780;&#27809;&#26377;&#35753;&#23545;&#24212;&#32447;&#31243;&#24471;&#21040;Job&#30340;&#35805;&#65292;&#37027;&#20040;&#37325;&#26032;&#25918;&#20837;&#36825;&#20010;Job.
        pCtx-&gt;pJobQ-&gt;push_back((Job*)pCtl); // should be shared queue
        thread_yield();                     // re-enqueue this job until the owner consumes it
        return true;
    }
    return false;
}
</pre>

<p>
通过这种方式来通知线程主动退出。理论上因为shared Queue可能会造成所有永远不会退出但是实际应该不会。
</p>
</div>

</div>

<div id="outline-container-1-2-2-3" class="outline-5">
<h5 id="sec-1-2-2-3"><span class="section-number-5">1.2.2.3</span> AddWorker &amp; DelWorker</h5>
<div class="outline-text-5" id="text-1-2-2-3">

<p>AddWorker非常简单
</p>


<pre class="src src-C++">int CThreadPool::_AddWorker(int nAdd)
{
    int i;

    for (i=0; i&lt;nAdd &amp;&amp; m_nWorkers&lt;m_nMaxWorkers; i++) {
        m_pContexts[m_nWorkers].fInit = m_fInit;
        if (m_pContexts[m_nWorkers].pJobQ == NULL) {
            m_pContexts[m_nWorkers].pJobQ = new JobQ; // &#20250;&#20026;&#27599;&#19968;&#20010;WorkerContext&#20998;&#37197;&#19968;&#20010;JobQ.&#23545;&#20110;&#20849;&#20139;Q&#30340;&#35805;&#22312;&#21021;&#22987;&#21270;&#23601;&#20998;&#37197;&#22909;&#20102;&#12290;
        }
        if (0 != thread_create(&amp;m_hWorkerThreads[m_nWorkers], NULL, WorkerProc, &amp;m_pContexts[m_nWorkers])) { // &#28982;&#21518;&#21551;&#21160;&#32447;&#31243;&#21363;&#21487;
            PERROR(<span class="org-string">"thread_create"</span>);
            break;
        }
        m_nWorkers ++;
    }
    return i;
}
</pre>


<p>
DelWorker因为有ControlJob的辅助所以可以很好地解决，只需要在每个线程后面增加一个TerminationJob即可
</p>


<pre class="src src-C++">int CThreadPool::_DelWorker(int nDel, bool bFinal)
{
    TerminationJob *pTerminations = new TerminationJob[nDel];
    int i;

    TRACE4(<span class="org-string">"%s start terminating %d workers...\n"</span>, ThreadType2Str(m_nType), nDel);
    for (i=0; i&lt;nDel &amp;&amp; m_nWorkers&gt;0; i++) {
        m_nWorkers --;
        DLINK_INITIALIZE(&amp;pTerminations[m_nWorkers].link);
        pTerminations[m_nWorkers].fZero = 0;
        pTerminations[m_nWorkers].fProc = TerminateWorker;
        pTerminations[m_nWorkers].id = bFinal ? -1 : m_nWorkers;
        m_pContexts[m_nWorkers].pJobQ-&gt;push_back((Job*)&amp;pTerminations[m_nWorkers]);
    }
    for (int j=m_nWorkers; j&lt;i+m_nWorkers; j++) {
        TRACE4(<span class="org-string">"%s wait for worker #%d.\n"</span>, ThreadType2Str(m_nType), j);
        thread_join(m_hWorkerThreads[j], NULL);
    }
    TRACE4(<span class="org-string">"%s end terminating workers.\n"</span>, ThreadType2Str(m_nType));
    delete[] pTerminations;
    return i;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-2-4" class="outline-5">
<h5 id="sec-1-2-2-4"><span class="section-number-5">1.2.2.4</span> QueueJob &amp; CancelJob</h5>
<div class="outline-text-5" id="text-1-2-2-4">

<p>相对来说QueueJob也更加简单一些，直接投递到某个线程对应的WorkerContext里面即可。
</p>


<pre class="src src-C++">void QueueJob(Job* pJob, int nWhich) {
     int nJobs = atomic_add(&amp;m_nJobs, 1);
    if (-1 == nWhich) {
        nWhich = nJobs % m_nWorkers;
    }
    atomic_add(&amp;m_pContexts[nWhich].nJobs, 1);
    m_pContexts[nWhich].pJobQ-&gt;push_back(pJob);
}
</pre>


<p>
而CancelJob则是通过加锁替换这个Job来完成的，还是比较精巧的
</p>


<pre class="src src-C++">static void
DoNothing(Job* pJob)
{
    free(pJob);
}

bool CThreadPool::CancelJob(Job* pJob, int nWhich)
{
    Job* p = ZeroAlloc&lt;Job&gt;(); // &#20998;&#37197;&#19968;&#20010;Job,&#32780;DoNothing&#23601;&#26159;&#23558;&#20854;&#37322;&#25918;&#25481;
    p-&gt;fProc = DoNothing;
    if (m_pContexts[nWhich].pJobQ-&gt;replace(pJob, p)) { // replace&#36825;&#20010;&#24037;&#20316;&#26159;&#19968;&#20010;&#21152;&#38145;&#23436;&#25104;&#30340;
        return true;
    }
    free(p); // &#22914;&#26524;&#27809;&#26377;Cancel&#30340;&#35805;&#37027;&#20040;&#36820;&#22238;&#22833;&#36133;&#20294;&#26159;&#20063;&#20250;&#37322;&#25918;&#25481;&#20869;&#23384;
    return false;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> TranBuf</h4>
<div class="outline-text-4" id="text-1-2-3">

<p>TranBuf.h CTranBufPool是一个内存分配器。对于很多系统来说，合理地使用资源是非常必要的。
</p>
<p>
这里引用linsd的原话是这样的TODO(blog):
</p>


<pre class="example">要得到稳定的高吞吐，对内存的合理使用是必要条件。是否用Ring Buffer倒不一定，简单的buffer pool效果也差不多。另外，为了应付极限情况，还需要为buffer请求分级，当资源不足时优先给紧急请求。也可设定高低几条watermark，让各种复杂条件下的资源使用变得平顺。
</pre>


<p>
了解一下真实系统里面定制话的内存分配器是非常有帮助的(相对来说 <a href="./TCMalloc.html">TCMalloc</a> 是通用系统).
</p>

</div>

<div id="outline-container-1-2-3-1" class="outline-5">
<h5 id="sec-1-2-3-1"><span class="section-number-5">1.2.3.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-2-3-1">

<p>首先看看CTranBufPool的数据结构，看看里面每个字段含义和作用.对于TranBuf来说的话内部
本质还是一个sample allocator，也是按照固定的BlockSize来进行分配的。构造函数可以看到水位线三个阈值都是0.
</p>


<pre class="src src-C++">class CTranBufPool : public CBufPoolV {
  struct Handle { // &#27599;&#20010;BlockSize&#23383;&#33410;&#20869;&#23384;&#20869;&#23384;&#30001;&#19968;&#20010;Handle&#31649;&#29702;.
    DLINK link; // &#20998;&#37197;&#20986;&#26469;&#20043;&#21518;&#22810;&#20010;Handle&#32452;&#25104;&#29615;&#24418;&#21452;&#21521;&#38142;&#34920;.
    char* pBuffer; // &#19968;&#20010;BlockSize&#30340;&#20869;&#23384;.
    Handle* pRealHdl; // &#30495;&#23454;Handler.&#36825;&#20010;&#20250;&#22312;&#21518;&#38754;&#35299;&#37322;.
    int nRef; // &#24341;&#29992;&#35745;&#25968;.
    int nConsBuf; // &#23545;&#20110;&#33258;&#24049;&#24341;&#29992;&#30340;pBuffer&#21518;&#38754;&#36824;&#26377;&#22810;&#23569;&#20010;&#36830;&#32493;&#20869;&#23384;.
  };
  typedef TLinkedList&lt;Handle&gt; FreeList; //
  typedef std::map&lt;char*, Handle*&gt; BufferMap; // buffer&#21644;Handle&#26144;&#23556;.

  FreeList m_FreeList;
  BufferMap m_BufferMap;

  // m_nBlockSize &#27599;&#20010;sample object&#21363;BlockSize
  // m_nBufferSize 1&#27425;&#36830;&#32493;&#24320;&#36767;&#22810;&#23569;&#23383;&#33410;.
  // m_nBlockBase log2(BlockSize)
  int m_nBlockSize, m_nBufferSize, m_nBlockBase;

  // m_nAlloc &#19968;&#27425;&#24320;&#36767;&#22810;&#23569;&#20010;BlockSize.&#20854;&#20013;m_nBufferSize=nAlloc*m_nBlockSize
  // m_nMaxBuffers &#26368;&#22810;&#20998;&#37197;&#22810;&#23569;&#20010;Blcok
  // m_nBuffers &#24403;&#21069;&#20998;&#37197;&#20102;&#22810;&#23569;&#20010;Block
  // m_nWaterMarks &#20998;&#20026;3&#20010;&#27700;&#20301;&#32447;
  int m_nAlloc, m_nMaxBuffers, m_nBuffers, m_nWaterMarks[3];

  // m_nMin. &#19968;&#24320;&#22987;&#33267;&#23569;&#20998;&#37197;m_nMin*nAlloc&#20010;Block
  // m_nMax &#26368;&#22810;&#20998;&#37197;m_nMax*nAlloc&#21733;block.&#20854;&#20013;m_nMaxBuffers=m_nMax*nAlloc.
  int m_nMin, m_nMax;
};

  CTranBufPool(const char* name, int nCategory) : CBufPoolV(name, nCategory) {
    m_nBuffers = 0;
    m_nBlockSize = m_nBufferSize = m_nAlloc = m_nMaxBuffers = m_nMin = 0;
    m_nWaterMarks[0] = m_nWaterMarks[1] = m_nWaterMarks[2] = 0;
</pre>

<p>
可以看到TranBuf分配方式是每次分配nAlloc个Block(这个过程在后面叫做AllocOnce).每个Block是BlockSize字节.
然后至少分配m_nMin*nAlloc(首先调用m_nMin个AllocOnce过程),最多分配m_nMax*nAlloc个Block.每个内存
不够的话都会调用AllocOnce这个过程。
</p>
<p>
这里稍微解释一下RealHdl这个字段的意思。对于单个Block分配出来的内存块，RealHdl==this.但是如果是
连续跨越多个Block内存快的话，那么每个Block对应的Handle里面RealHdl对应的是首地址的Handle.这样做的好处就是，
如果希望对这个内存块增加或者是减少引用计数的话，只是指引到一个Handle，对里面字段修改引用计数。否则的话，
需要遍历每个Block对应的Handle修改引用技术。
</p>
</div>

</div>

<div id="outline-container-1-2-3-2" class="outline-5">
<h5 id="sec-1-2-3-2"><span class="section-number-5">1.2.3.2</span> Create</h5>
<div class="outline-text-5" id="text-1-2-3-2">

<p>大部分Create代码都是在设置参数，最后调用m_nMin次AllocOnce来分配初始的内存块。
</p>


<pre class="src src-C++">bool Create(int nBlockSize, int nAlloc, int nMin, int nMax, double fRatio1, double fRatio2) {
  m_nUnitSize = nBlockSize;
  m_nBlockSize = nBlockSize;
  m_nBlockBase = Log_2(nBlockSize);
  if (-1 == m_nBlockBase) {
    TRACE0(<span class="org-string">"Fatal: invalid block size of %d\n"</span>, nBlockSize);
    return false;
  }
  m_nAlloc = nAlloc;
  m_nMaxBuffers = nMax * nAlloc;
  m_nBufferSize = m_nBlockSize * m_nAlloc;
  m_nBuffers = 0;
  m_nMax = nMax;
  m_nMin = nMin;
  if (0 != fRatio1 &amp;&amp; 0 != fRatio2) {
    m_nWaterMarks[0] = (int)((double)m_nMaxBuffers * fRatio1);
    m_nWaterMarks[1] = (int)((double)m_nMaxBuffers * fRatio2);
    m_nWaterMarks[2] = m_nMaxBuffers - 1;
  }
  for (int i = 0; i &lt; m_nMin; i++) {
    if (!AllocOnce()) // &#27880;&#24847;&#36825;&#37324;&#27809;&#26377;&#24517;&#35201;&#22238;&#28378;&#65292;&#27599;&#27425;&#25104;&#21151;&#37117;&#20250;&#35760;&#24405;&#29366;&#24577;&#65292;&#22312;Destroy&#37324;&#38754;&#20250;&#37322;&#25918;&#25481;&#12290;
      return false;
  }
  return true;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-3-3" class="outline-5">
<h5 id="sec-1-2-3-3"><span class="section-number-5">1.2.3.3</span> AllocOnce</h5>
<div class="outline-text-5" id="text-1-2-3-3">

<p>之前说过AllocOnce是分配一个连续内存块，每个Block大小是m_nBlockSize,而个数是nAlloc.
同时还需要分配nAlloc个Handle.每个Handle管理一个Block.
</p>


<pre class="src src-C++">bool AllocOnce() {
  char* pBuffer = (char*)AlignAlloc(m_nBlockSize, m_nBufferSize);
  Handle* pHdl = (Handle*)ZeroAlloc(m_nAlloc * sizeof(Handle));
  if (pBuffer &amp;&amp; pHdl) {
    m_BufferMap.insert(BufferMap::value_type(pBuffer, pHdl)); // &#35760;&#24405;&#19979;&#36825;&#20010;&#36830;&#32493;&#22359;&#30340;&#20869;&#23384;&#22320;&#22336;&#21644;Handle&#22320;&#22336;.
    // &#22312;Destroy&#26102;&#20505;&#26377;&#29992;.
    m_nBuffers += m_nAlloc;
    pBuffer += m_nBufferSize - m_nBlockSize;
    pHdl += m_nAlloc - 1;

    for (int i = 0; i &lt; m_nAlloc; i++) { // &#28982;&#21518;&#23558;&#25105;&#25152;&#26377;&#30340;Block&#21152;&#20837;&#21040;&#38142;&#34920;&#37324;&#38754;&#21435;.
      pHdl-&gt;pBuffer = pBuffer;
      pHdl-&gt;nRef = 0;
      pHdl-&gt;nConsBuf = i + 1;
      pHdl-&gt;pRealHdl = pHdl;
      m_FreeList.push_back(pHdl); // &#23545;&#20110;ConsBuf&#22823;&#30340;Handle&#25918;&#22312;&#38142;&#34920;&#26368;&#21518;.
      // &#20174;&#21518;&#38754;&#20869;&#23384;&#20998;&#37197;&#31574;&#30053;&#23601;&#21487;&#20197;&#21457;&#29616;&#65292;&#23545;&#20110;&#20998;&#37197;&#36830;&#32493;Handle&#30340;&#35805;&#37117;&#26159;&#20174;&#26368;&#21518;&#24320;&#22987;&#30340;&#12290;

      pBuffer -= m_nBlockSize;
      pHdl --;
    }
    return true;
  }
  if (pBuffer)
    free(pBuffer);
  if (pHdl)
    free(pHdl);
  return false;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-3-4" class="outline-5">
<h5 id="sec-1-2-3-4"><span class="section-number-5">1.2.3.4</span> GetHandle</h5>
<div class="outline-text-5" id="text-1-2-3-4">

<p>GetHandle是通过传入buffer首地址来确定管理这个buffer的Handle.但是注意不是RealHdl.
如果需要对这个内存做引用计数的话，应该是对RealHdl做引用计数。可以看看下面的AddRef实现。
</p>


<pre class="src src-C++">Handle* GetHandle(char* pBuffer) {
  BufferMap::iterator it = m_BufferMap.upper_bound(pBuffer);
  if (it != m_BufferMap.begin()) {
    it --;

    char* pHead = it-&gt;first;
    ASSERT(pHead &lt;= pBuffer);
    if (pBuffer &lt; pHead + m_nBufferSize) {
      int n = (pBuffer - pHead) &gt;&gt; m_nBlockBase;
      Handle* pHdl = it-&gt;second + n;
      ASSERT(pHdl-&gt;pBuffer == pHead + (((uint32)n) &lt;&lt; m_nBlockBase));
      return pHdl;
    }
  }
  return NULL;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-3-5" class="outline-5">
<h5 id="sec-1-2-3-5"><span class="section-number-5">1.2.3.5</span> AddRef</h5>
<div class="outline-text-5" id="text-1-2-3-5">

<p>对某块内存进行引用计数。并且强大的是这个内存地址不必是分配的首地址，可以是连续内存内部任意地址。
</p>


<pre class="src src-C++">int AddRef(char* p, bool bCheck = false) {
  Handle* pHdl = GetHandle(p);
  if (NULL == pHdl) {
    if (!bCheck) {
      return -1;
    }
    RaiseError(Invalid_Block);
  }

  int n = ++ pHdl-&gt;pRealHdl-&gt;nRef;
  ASSERT(2 &lt;= n);
  return n;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-3-6" class="outline-5">
<h5 id="sec-1-2-3-6"><span class="section-number-5">1.2.3.6</span> Destroy</h5>
<div class="outline-text-5" id="text-1-2-3-6">

<p>Destroy是将AllocOnce分配的内存和Handle全部回收。因为得到了所有分配内存和Handle的起始地址
保存在map里面所以释放并不麻烦.
</p>


<pre class="src src-C++">void Destroy() {
  m_FreeList.Init();
  m_nBuffers = 0; // &#23558;&#20998;&#37197;&#35745;&#25968;&#28165;&#38646;.

  BufferMap::iterator it;
  for (it = m_BufferMap.begin(); it != m_BufferMap.end(); it++) {
    free(it-&gt;first);
    free(it-&gt;second);
  }
  m_BufferMap.clear();
}
</pre>


</div>

</div>

<div id="outline-container-1-2-3-7" class="outline-5">
<h5 id="sec-1-2-3-7"><span class="section-number-5">1.2.3.7</span> Allocate</h5>
<div class="outline-text-5" id="text-1-2-3-7">

<p>分配内存。可以从参数里面看出来语义是说分配多少个Block.nPriority参数是说使用哪个水位线。
如果超过水位线的话，那么会使用相应的策略来处理(打印日志)。
</p>


<pre class="src src-C++">// &#20174;freelist&#37324;&#38754;&#20998;&#37197;&#19968;&#20010;block&#20986;&#26469;.
#define _ALLOC_TRAN_BUF(p, how)                     \
  p = m_FreeList.how();                           \
  ASSERT(DLINK_IS_STANDALONE(&amp;p-&gt;link));          \
  ASSERT(0 == p-&gt;nRef);                           \
  ASSERT(p-&gt;pRealHdl == p);                       \
  p-&gt;nRef = 1

  char* Allocate(uint32 nPriority, int count = 1) {
    int n;
    ASSERT(0 != count);
    // &#20250;&#23581;&#35797;&#20998;&#37197;&#20004;&#27425;&#12290;&#31532;&#19968;&#27425;&#19981;&#36827;&#34892;AllocOnce.&#22914;&#26524;&#31532;&#19968;&#27425;&#22833;&#36133;&#30340;&#35805;&#37027;&#20040;&#31532;&#20108;&#27425;&#20250;&#23581;&#35797;&#12290;
    for (int i = 0; i &lt; 2; i++) {
      n = (int)m_FreeList.size();
      // &#22914;&#26524;&#24403;&#21069;&#20998;&#37197;&#20869;&#23384;&#22823;&#20110;water mark&#30340;&#35805;&#20250;&#25171;&#21360;&#26085;&#24535;&#65292;&#20294;&#26159;&#20026;&#20102;&#36807;&#24555;&#30340;&#25171;&#21360;&#36825;&#37324;&#25511;&#21046;&#20102;&#25171;&#21360;&#38388;&#38548;
      // &#20174;&#36825;&#37324;&#21487;&#20197;&#30475;&#21040;&#36825;&#20010;&#26159;&#38750;&#22810;&#32447;&#31243;&#30340;&#12290;&#20174;&#21518;&#38754;BufHandle&#20351;&#29992;&#26469;&#30475;&#30830;&#23454;&#26159;&#36825;&#26679;&#30340;&#12290;
      if (m_nBuffers - n &gt; m_nWaterMarks[nPriority]) {
        if (nPriority != 0) {
          static time_t last = 0;
          time_t now = time(NULL);
          if (now - last &gt;= 30) {   // avoid too frequent print
            int n1 = m_nMaxBuffers - m_nBuffers + n;
            int n2 = m_nMaxBuffers - m_nWaterMarks[nPriority];
            TRACE0(<span class="org-string">"Warning: available tran buf (#%d) touches watermark(#%d, %.f%%)\n"</span>,
                   n1, n2, (double)(n1 * 100) / m_nMaxBuffers);
            last = now;
          }
        }
        return NULL;
      }
      if (n &gt;= count) {  // &#22914;&#26524;free list&#37324;&#38754;&#20869;&#23481;&gt;=count&#30340;&#35805;&#65292;&#20294;&#26159;&#26377;&#21487;&#33021;&#27809;&#26377;&#36830;&#32493;&#20869;&#23384;&#29992;&#26469;&#20998;&#37197;&#12290;
        Handle* pHdl, *pTmp;
        if (1 == count) { // &#22914;&#26524;&#20998;&#37197;1&#20010;&#30340;&#35805;&#65292;&#37027;&#20040;&#30452;&#25509;&#20174;&#21069;&#38754;&#20998;&#37197;
          _ALLOC_TRAN_BUF(pHdl, pop_front);
          return pHdl-&gt;pBuffer;
        }
        // &#21542;&#21017;&#20250;&#20174;&#21518;&#38754;&#20998;&#37197;&#65292;&#22240;&#20026;&#21518;&#38754;Consecutive Buffer&#30340;&#27010;&#29575;&#20250;&#26356;&#39640;&#12290;
        // Big block are formed by multiple consecutive blocks.
        // We try from the tail of free list, which brings higher probability.
        _ALLOC_TRAN_BUF(pHdl, pop_back);
        int i = 1;
        if (pHdl-&gt;nConsBuf &gt;= count) { // &#30475;&#30475;&#26368;&#21518;&#30340;Handle&#30340;consectutive number&#26159;&#21542;&#36275;&#22815;.
          for ( ; i &lt; count; i++) { // &#24182;&#19988;&#30475;&#30475;&#26159;&#21542;&#34987;&#21344;&#29992;(&#36890;&#36807;&#24341;&#29992;&#35745;&#25968;&#21028;&#26029;).&#36825;&#37324;&#27809;&#26377;&#32454;&#30475;&#38142;&#34920;&#30340;&#32452;&#32455;&#12290;
            pTmp = pHdl + i;
            UNLIKELY_IF (0 != pTmp-&gt;nRef) {
              break;
            }
            m_FreeList.remove(pTmp);
            DLINK_INSERT_PREV(&amp;pHdl-&gt;link, &amp;pTmp-&gt;link);
            pTmp-&gt;pRealHdl = pHdl;
            pTmp-&gt;nRef = 1;
          }
        }
        if (i == count) { // &#22914;&#26524;&#20998;&#37197;OK&#30340;&#35805;,&#37027;&#20040;&#36820;&#22238;
          return pHdl-&gt;pBuffer;
        } else { // &#21542;&#21017;&#30340;&#35805;&#37027;&#20040;&#38656;&#35201;&#36827;&#34892;&#22238;&#28378;.
          for (int j = 0; j &lt; i; j++) {
            pTmp = pHdl + j;
            DLINK_INITIALIZE(&amp;pTmp-&gt;link);
            pTmp-&gt;pRealHdl = pTmp;
            pTmp-&gt;nRef = 0;
            m_FreeList.push_front(pTmp);
          }
        }
      }
      // &#22914;&#26524;&#20998;&#37197;&#20869;&#23384;&#36229;&#38480;&#25110;&#32773;&#26159;AllocOnce&#20998;&#37197;&#22833;&#36133;&#30340;&#35805;&#65292;&#37027;&#20040;&#30452;&#25509;&#36820;&#22238;&#12290;
      if (m_nBuffers &gt;= m_nMaxBuffers || !AllocOnce()) {
        return NULL;
      }
    }
    return NULL;
  }
</pre>


</div>

</div>

<div id="outline-container-1-2-3-8" class="outline-5">
<h5 id="sec-1-2-3-8"><span class="section-number-5">1.2.3.8</span> Free</h5>
<div class="outline-text-5" id="text-1-2-3-8">




<pre class="src src-C++">#ifdef  _DEBUG
#define _FREE_TRAN_BUF(p, how)                              \
  memset(p-&gt;pBuffer, 0xCC, m_nBlockSize);             \
  m_FreeList.how(p)
#else
#define _FREE_TRAN_BUF(p, how)                              \
  m_FreeList.how(p)
#endif

  int Free(char* p, bool bCheck = false) {
    Handle* pHdl = GetHandle(p);
    if (NULL == pHdl) {
      if (bCheck) {
        RaiseError(Invalid_Block);
      }
      return -1;
    }

    pHdl = pHdl-&gt;pRealHdl;
    int n = -- pHdl-&gt;nRef; // &#20462;&#25913;&#24341;&#29992;&#35745;&#25968;&#12290;
    if (0 == n) {
      Handle* pTmp = dlink_get_prev(pHdl);
      if (pTmp == pHdl) { // &#22914;&#26524;&#26159;&#19968;&#20010;Block&#30340;&#35805;.
        ASSERT_EQUAL(pHdl-&gt;pRealHdl, pHdl);
        ASSERT_EQUAL(0, pHdl-&gt;nRef);
        _FREE_TRAN_BUF(pHdl, push_front);
        return 0;
      }
      // here comes big block
      Handle* p = pHdl; // &#25105;&#20204;&#30693;&#36947;&#36825;&#20010;Handle&#32452;&#32455;&#31216;&#20026;&#29615;&#24418;&#21452;&#21521;&#38142;&#34920;&#12290;
      // &#21516;&#26679;&#25353;&#29031;AllocOnce&#30340;&#39034;&#24207;&#65292;&#23558;consecutive number&#22823;&#30340;handle&#25918;&#22312;&#26411;&#23614;.
      do {
        pHdl = pTmp;
        pTmp = dlink_get_prev(pTmp);
        ASSERT_EQUAL(1, pHdl-&gt;nRef);
        ASSERT_EQUAL(p, pHdl-&gt;pRealHdl);
        pHdl-&gt;pRealHdl = pHdl;
        pHdl-&gt;nRef = 0;
        DLINK_INITIALIZE(&amp;pHdl-&gt;link);
        _FREE_TRAN_BUF(pHdl, push_back);
      } while (p != pTmp);
      ASSERT_EQUAL(p, p-&gt;pRealHdl);
      ASSERT_EQUAL(0, p-&gt;nRef);
      DLINK_INITIALIZE(&amp;p-&gt;link);
      _FREE_TRAN_BUF(p, push_back);
      return 0;
    }
    return n;
  }
</pre>


</div>
</div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> BufHandle</h4>
<div class="outline-text-4" id="text-1-2-4">

<p>如果说TranBuf是底层内存分配器的话，那BufHandle就是应用层的内存分配器。BufHandle底层是通过
两个TranBuf来进行分配的。BufHandle本质上是chained的形式，主要是为了节省mem copy以及适应
network IO app的。通过全局的BufHandlePool对象来分配内存。
</p>

</div>

<div id="outline-container-1-2-4-1" class="outline-5">
<h5 id="sec-1-2-4-1"><span class="section-number-5">1.2.4.1</span> OverView</h5>
<div class="outline-text-5" id="text-1-2-4-1">

<p>首先我们看看BufHandle结构以及提供的API.
</p>


<pre class="src src-C++">struct BufHandle {
  BufHandle* _next; // &#38142;&#24335;&#25351;&#38024;.
  char* pBuf; // &#31649;&#29702;&#30340;&#20869;&#23384;.
  int nBufLen;      // available buffer length &#21487;&#29992;&#38271;&#24230;
  int nDataLen;     // occupied data length &#21344;&#29992;&#38271;&#24230;
};

// &#20174;[pHdl,pNext)&#36825;&#20010;&#21306;&#38388;&#19978;&#38754;&#22238;&#25910;nLen&#38271;&#24230;&#20986;&#26469;&#20998;&#37197;&#20986;&#21435;.
BufHandle* Reclaim(int nLen, BufHandle* pHdl, BufHandle* pNext);

// &#35774;&#32622;TranBuf&#30340;&#21442;&#25968;.&#36825;&#20010;&#24212;&#35813;&#22312;Kylin&#35843;&#29992;&#20043;&#21069;&#23601;&#35774;&#32622;&#22909;&#65292;&#22914;&#26524;&#25171;&#31639;&#20351;&#29992;BufHandle&#30340;&#35805;&#12290;
void SetTranBuf(int nSmallNum, int nBigNum,
                int nSmallSize = 4096,
                float fLowMark = 0.6f,
                float fHighMark = 0.9f);

// NOTICE(blog):&#36825;&#37324;&#22914;&#26524;&#19981;&#20801;&#35768;&#22833;&#36133;&#30340;&#35805;&#65292;&#37027;&#20040;&#23601;&#20250;&#30452;&#25509;&#25243;&#20986;&#24322;&#24120;.
// inPool&#34920;&#31034;&#36825;&#20010;buf&#26159;&#21542;&#22312;pool&#37324;&#38754;&#22914;&#26524;&#26159;&#30340;&#35805;&#37027;&#20040;&#21487;&#20197;&#30452;&#25509;&#20351;&#29992;&#24341;&#29992;&#35745;&#25968;&#20248;&#21270;&#20943;&#23569;copy
// pBuf&#34920;&#31034;src&#20869;&#23384;&#22320;&#22336;,nLen&#34920;&#31034;src&#20869;&#23384;&#38271;&#24230;.pNext&#34920;&#31034;allocate handle&#20043;&#21518;next&#23383;&#27573;&#20540;.
// &#22914;&#26524;&#19981;&#26159;inPool&#30340;&#35805;&#65292;&#37027;&#20040;&#20174;TranBufPool&#37324;&#38754;&#20998;&#37197;.
BufHandle* AllocateHdl(bool bInPool = false, char* pBuf = NULL,
                       int nLen = 0, BufHandle* pNext = NULL);
// &#20174;TranBufPool&#37324;&#38754;&#20998;&#37197;&#20801;&#35768;&#22833;&#36133;.
BufHandle* AllocateHdlCanFail(int nSize = 0);
// &#20174;big pool&#37324;&#38754;&#20998;&#37197;1&#20010;block.
BufHandle* AllocateBigHdl();
BufHandle* AllocateBigHdlCanFail();

// &#37322;&#25918;&#36825;&#20010;Handle.
void FreeHdl(BufHandle* pHdl);
// &#38142;&#24335;&#37322;&#25918;[pHdl,pNext)&#30340;&#38142;&#24335;&#37324;&#38754;&#30340;&#31354;&#38388;.
void ChainFreeHdl(BufHandle* pHdl, BufHandle* pNext);
// &#36825;&#20010;&#21517;&#23383;&#21462;&#24471;&#19981;&#22826;&#22909;&#21548;&#65292;&#26412;&#36136;&#26469;&#35828;&#23601;&#26159;&#36827;&#34892;Clone
// pnLen&#25968;&#25454;&#38271;&#24230;&#26159;&#22810;&#23569;.bCopyNonTranBuf&#34920;&#31034;&#22914;&#26524;&#19981;&#33021;&#22815;&#20570;&#24341;&#29992;&#35745;&#25968;&#30340;&#35805;&#65292;&#26159;&#21542;&#38656;&#35201;copy.
BufHandle* CloneHdlAndTerminate(BufHandle* pHdl, BufHandle* pNext,
                                int* pnLen = NULL, bool bCopyNonTranBuf = true);
</pre>


</div>

</div>

<div id="outline-container-1-2-4-2" class="outline-5">
<h5 id="sec-1-2-4-2"><span class="section-number-5">1.2.4.2</span> SetTranBuf</h5>
<div class="outline-text-5" id="text-1-2-4-2">

<p>首先我们先看看CBufHandlePool的结构然后在看这个API
</p>


<pre class="src src-C++">// &#32487;&#25215;&#20110;TObjectPool&#23545;&#35937;&#27744;&#21487;&#20197;&#30452;&#25509;&#39640;&#25928;&#20998;&#37197;&#20986;BufHandle&#23545;&#35937;&#20986;&#26469;.
class CBufHandlePool : public TObjectPool&lt;BufHandle&gt; {
  volatile int m_lock; // &#22810;&#32447;&#31243;&#23433;&#20840;.
  CTranBufPool m_TranBufPool; // tran buf pool
  CTranBufPool m_BigBufPool; // big buf pool
};

  CBufHandlePool() : TObjectPool&lt;BufHandle&gt;(<span class="org-string">"BufHandle"</span>, BUFPOOL_C2),
    m_TranBufPool(<span class="org-string">"TranBuffer"</span>, BUFPOOL_C1),
    m_BigBufPool(<span class="org-string">"BigBuffer"</span>, BUFPOOL_C1) {
    m_lock = 0;
    Create(1024, 1);

    int nAlloc = s_nTranBuf;
    int nMax = 1;
    // &#19968;&#27425;&#19981;&#35201;&#20998;&#37197;&#36229;&#36807;512M.&#20294;&#26159;&#20026;&#20102;&#20445;&#25345;&#20869;&#23384;&#24635;&#37327;&#20801;&#35768;nMax&#22686;&#22823;.
    while ((s_nBufSize / 1024) * nAlloc &gt; 524288) { /* Max alloc: 512M */
      nAlloc &gt;&gt;= 1;
      nMax &lt;&lt;= 1;
    }
    // tranbuf&#35774;&#32622;&#21442;&#25968;.
    m_TranBufPool.Create(s_nBufSize, nAlloc, 1, nMax, s_fLowMark, s_fHighMark);
    // &#21487;&#20197;&#30475;&#21040;big buf&#30340;block size&#38750;&#24120;&#22823;.&#24182;&#19988;watermark&#38750;&#24120;&#39640;.&#20998;&#37197;&#27425;&#25968;&#22312;[0,10]&#20043;&#38388;.
    m_BigBufPool.Create(SZ_BIG_BUF, s_nBigTranBuf, 0, 10, 0.9, 0.9);
  }

// &#21333;&#20363;&#27169;&#24335;.
static CBufHandlePool* s_pBufHandlePool = NULL;
static CBufHandlePool* GetBufHdlPool() {
  if (NULL != s_pBufHandlePool) {
    return s_pBufHandlePool;
  } else {
    LOCK_THIS_BLOCK;
    if (NULL == s_pBufHandlePool) {
      s_pBufHandlePool = new CBufHandlePool;
    }
    return s_pBufHandlePool;
  }
}
</pre>


<p>
然后来看看这些参数是来如何设置的.
</p>


<pre class="src src-C++">int s_nTranBuf = 1024;
int s_nBufSize = 4096;
int s_nBigTranBuf = 64;
float s_fLowMark = 0.6f;
float s_fHighMark = 0.9f;

void SetTranBuf(int nSmallNum, int nBigNum, int nSmallSize, float fLowMark, float fHighMark) {
  LOCK_THIS_BLOCK;

  s_nTranBuf = nSmallNum; // tran buf&#24212;&#35813;&#27599;&#27425;alloc&#22810;&#23569;&#20010;block.
  s_nBigTranBuf = nBigNum; // big tran buf&#27599;&#27425;&#24212;&#35813;allocate&#22810;&#23569;&#20010;block.
  s_nBufSize = nSmallSize; // tran buf&#30340;blocksize.
  s_fLowMark = fLowMark;
  s_fHighMark = fHighMark;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-4-3" class="outline-5">
<h5 id="sec-1-2-4-3"><span class="section-number-5">1.2.4.3</span> DoAllocate</h5>
<div class="outline-text-5" id="text-1-2-4-3">

<p>这个是底层确保一定分配成功API(如果失败抛异常).来看看实现.使用hang住当前操作等待其他线程归还内存.
</p>


<pre class="src src-C++">// &#20174;&#20160;&#20040;pool&#37324;&#38754;&#36827;&#34892;&#20998;&#37197;&#65292;&#23581;&#35797;&#22810;&#23569;&#27425;&#20998;&#37197;.
BufHandle* DoAllocate(CTranBufPool* pPool, int nRetry) {
  BufHandle* pHdl;

  for (int i = 0; i &lt; nRetry; i++) {
    LOCK;
    pHdl = TObjectPool&lt;BufHandle&gt;::Allocate(); // &#39318;&#20808;&#20174;&#23545;&#35937;&#27744;&#37324;&#38754;&#20998;&#37197;BufHandle&#23545;&#35937;.
    pHdl-&gt;pBuf = pPool-&gt;Allocate(i &gt; 0 ? 2 : 1); // &#28982;&#21518;&#20174;tran buf pool&#37324;&#38754;&#20998;&#37197;.
    // &#27880;&#24847;&#36825;&#37324;&#31532;&#19968;&#27425;&#25353;&#29031;water mark1&#26469;&#20998;&#37197;,&#20043;&#21518;&#25353;&#29031;water mark2&#26469;&#20998;&#37197;.
    if (NULL == pHdl-&gt;pBuf) { // &#22914;&#26524;&#20998;&#37197;&#22833;&#36133;&#30340;&#35805;&#65292;&#37027;&#20040;&#36820;&#22238;&#23545;&#35937;&#27744;.
      TObjectPool&lt;BufHandle&gt;::Free(pHdl);
      pHdl = NULL;
    }
    UNLOCK;
    if (NULL != pHdl) // &#22914;&#26524;&#25104;&#21151;&#30452;&#25509;&#36820;&#22238;.
      return pHdl;
    if (i &gt; 1) {
      TRACE0(<span class="org-string">"No enough memory, sleep %d\n"</span>, i + 1);
    }
    sleep(1); // &#21542;&#21017;&#20250;hang&#20303;&#31561;&#24453;&#37322;&#25918;.
  }
  RaiseError(TODO_NO_ENOUGH_MEMORY); // &#22914;&#26524;&#27809;&#26377;&#20998;&#37197;&#25104;&#21151;&#37027;&#20040;&#23601;&#20250;&#25243;&#20986;&#24322;&#24120;.
  return NULL;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-4-4" class="outline-5">
<h5 id="sec-1-2-4-4"><span class="section-number-5">1.2.4.4</span> DoAllocateCanFail</h5>
<div class="outline-text-5" id="text-1-2-4-4">

<p>底层不一定保证分配成功，可能返回NULL表示失败.只是尝试一次分配.
</p>


<pre class="src src-C++">BufHandle* DoAllocateCanFail(CTranBufPool* pPool, int nSize) {
  BufHandle* pHdl;
  int nBlockSize = pPool-&gt;GetBlockSize();
  ASSERT(0 != nSize);

  LOCK;
  pHdl = TObjectPool&lt;BufHandle&gt;::Allocate();
  // &#20197;water mark0&#20026;&#26631;&#35760;.
  if (nSize == nBlockSize) {
    pHdl-&gt;pBuf = pPool-&gt;Allocate(0);
  } else {
    pHdl-&gt;pBuf = pPool-&gt;Allocate(0, (nSize + nBlockSize - 1) / nBlockSize);
  }
  if (NULL == pHdl-&gt;pBuf) {
    TObjectPool&lt;BufHandle&gt;::Free(pHdl);
    pHdl = NULL;
  }
  UNLOCK;
  return pHdl;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-4-5" class="outline-5">
<h5 id="sec-1-2-4-5"><span class="section-number-5">1.2.4.5</span> _DoAddRef</h5>
<div class="outline-text-5" id="text-1-2-4-5">

<p>对于BufHandle的引用技术和TranPool引用计数有点不同，并且平时思考的也不同。BufHandle的引用计数
只是针对头部的BufHandle增加计数而共用其他部分的BufHandle.
</p>
<p>
(NOTICE)(blog):(不过在外部调用可以看到,CloneAndTerminate实际上也还是遍历了所有的Handle做引用计数).
</p>


<pre class="src src-C++">BufHandle* _DoAddRef(BufHandle* pHdl, BufHandle* pNext, BufHandle** * pppLast) {
  if (-1 != m_TranBufPool.AddRef(pHdl-&gt;pBuf) || -1 != m_BigBufPool.AddRef(pHdl-&gt;pBuf)) {
    BufHandle* pTmp = TObjectPool&lt;BufHandle&gt;::Allocate();
    pTmp-&gt;_next = pNext;
    pTmp-&gt;pBuf = pHdl-&gt;pBuf;
    pTmp-&gt;nBufLen = pHdl-&gt;nDataLen;
    pTmp-&gt;nDataLen = pHdl-&gt;nDataLen;
    *pppLast = &amp;pTmp-&gt;_next;
    return pTmp;
  }
  return NULL;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-4-6" class="outline-5">
<h5 id="sec-1-2-4-6"><span class="section-number-5">1.2.4.6</span> _DoFree</h5>
<div class="outline-text-5" id="text-1-2-4-6">

<p>只是释放单个BufHandle对象.
</p>


<pre class="src src-C++">void _DoFree(BufHandle* pHdl) {
  if (-1 == m_TranBufPool.Free(pHdl-&gt;pBuf))
    m_BigBufPool.Free(pHdl-&gt;pBuf);
  TObjectPool&lt;BufHandle&gt;::Free(pHdl);
}
</pre>


</div>

</div>

<div id="outline-container-1-2-4-7" class="outline-5">
<h5 id="sec-1-2-4-7"><span class="section-number-5">1.2.4.7</span> AllocateBig</h5>
<div class="outline-text-5" id="text-1-2-4-7">

<p>从BigTranBufPool里面分配大块内存.注意对于大块内存而言的话只允许分配一个Block.
</p>


<pre class="src src-C++">BufHandle* AllocateBig(bool bCanFail) {
  BufHandle* pHdl;

  pHdl = bCanFail
         ? DoAllocateCanFail(&amp;m_BigBufPool, SZ_BIG_BUF)
         : DoAllocate(&amp;m_BigBufPool, 60); // 60s&#30340;&#24310;&#36831;.
  if (pHdl) {
    pHdl-&gt;_next = NULL;
    pHdl-&gt;nBufLen = SZ_BIG_BUF;
    pHdl-&gt;nDataLen = 0;
  }
  return pHdl;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-4-8" class="outline-5">
<h5 id="sec-1-2-4-8"><span class="section-number-5">1.2.4.8</span> AllocateCanFail</h5>
<div class="outline-text-5" id="text-1-2-4-8">

<p>从TranBufPool里面分配连续内存出来.
</p>


<pre class="src src-C++">BufHandle* AllocateCanFail(int nSize) {
  BufHandle* pHdl = DoAllocateCanFail(&amp;m_TranBufPool, nSize);
  if (pHdl) {
    pHdl-&gt;_next = NULL;
    pHdl-&gt;nBufLen = nSize;
    pHdl-&gt;nDataLen = 0;
  }
  return pHdl;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-4-9" class="outline-5">
<h5 id="sec-1-2-4-9"><span class="section-number-5">1.2.4.9</span> AllocForBuf</h5>
<div class="outline-text-5" id="text-1-2-4-9">

<p>为某个buf分配内存.把buf内容copy进来.并且设置pNext.pppLast表示最后一个节点的next字段指针(三指针比较难理解&hellip;)
</p>


<pre class="src src-C++">BufHandle* AllocForBuf(char* pBuf, int nLen, BufHandle* pNext, BufHandle** * pppLast) {
  BufHandle* pFirst, *pHdl, **ppLast;

  pFirst = NULL;
  ppLast = &amp;pFirst;
  while (nLen &gt; 0) {
    pHdl = DoAllocate(&amp;m_TranBufPool, 120); // 120s&#24310;&#36831;.

    pHdl-&gt;nBufLen = s_nBufSize;
    pHdl-&gt;nDataLen = nLen &gt; s_nBufSize ? s_nBufSize : nLen;
    memcpy(pHdl-&gt;pBuf, pBuf, pHdl-&gt;nDataLen);
    pBuf += pHdl-&gt;nDataLen;
    nLen -= pHdl-&gt;nDataLen;

    pHdl-&gt;_next = pNext; // &#35774;&#32622;next&#23383;&#27573;&#20869;&#23481;
    *ppLast = pHdl;
    ppLast = &amp;pHdl-&gt;_next; // &#24182;&#19988;&#24471;&#21040;&#26368;&#21518;&#19968;&#20010;item&#30340;next&#23383;&#27573;&#25351;&#38024;.
    // &#19981;&#36807;&#22240;&#20026;&#35774;&#32622;&#20102;pNext&#25152;&#20197;&#24863;&#35273;&#19981;&#26159;&#29305;&#21035;&#26377;&#29992;.
  }
  if (pppLast) {
    *pppLast = ppLast;
  }
  return pFirst;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-4-10" class="outline-5">
<h5 id="sec-1-2-4-10"><span class="section-number-5">1.2.4.10</span> Allocate</h5>
<div class="outline-text-5" id="text-1-2-4-10">




<pre class="src src-C++">// &#22914;&#26524;&#26159;inpool&#30340;&#35805;&#65292;&#37027;&#20040;pubuf&#24517;&#39035;&#26159;pool&#20998;&#37197;&#20986;&#26469;&#30340;&#65292;
// &#37027;&#20040;&#25105;&#20204;&#21482;&#26159;&#38024;&#23545;&#36825;&#20010;buffer&#20570;&#19968;&#20010;&#24341;&#29992;&#35745;&#25968;

// &#22914;&#26524;&#19981;&#26159;inpool&#30340;&#35805;&#65292;nLen==0&#25110;&#32773;&#26159;pBuf==NULL,&#20998;&#37197;&#20986;&#19968;&#20010;&#31354;&#21333;&#20803;&#20986;&#26469;.
// &#21542;&#21017;&#38656;&#35201;&#20570;&#19968;&#20010;&#20869;&#23384;copy.&#20351;&#29992;&#19978;&#38754;AllocForBuf&#30340;API.
BufHandle* Allocate(bool bInPool = false, char* pBuf = NULL,
                    int nLen = 0, BufHandle* pNext = NULL
                   ) {
  BufHandle* pHdl;

  UNLIKELY_IF (false == bInPool) {
    LOCK;
    pHdl = TObjectPool&lt;BufHandle&gt;::Allocate();
    if (-1 == m_TranBufPool.AddRef(pBuf))
      m_BigBufPool.AddRef(pBuf);
    UNLOCK;

    pHdl-&gt;_next = pNext;
    pHdl-&gt;pBuf = pBuf;
    pHdl-&gt;nBufLen = nLen;
    pHdl-&gt;nDataLen = nLen;
    return pHdl;
  }
  if (pBuf == NULL || nLen == 0) {
    pHdl = DoAllocate(&amp;m_TranBufPool, 120);

    pHdl-&gt;_next = pNext;
    pHdl-&gt;nBufLen = s_nBufSize;
    pHdl-&gt;nDataLen = nLen;
    return pHdl;
  }

  return AllocForBuf(pBuf, nLen, pNext, NULL);
}
</pre>


</div>

</div>

<div id="outline-container-1-2-4-11" class="outline-5">
<h5 id="sec-1-2-4-11"><span class="section-number-5">1.2.4.11</span> ChainFree</h5>
<div class="outline-text-5" id="text-1-2-4-11">

<p>释放[pHdl,pNext)链上的所有item.
</p>


<pre class="src src-C++">void ChainFree(BufHandle* pHdl, BufHandle* pNext) {
  BufHandle* pTmp;
  LOCK;
  for ( ; pHdl != pNext; pHdl = pTmp) {
    ASSERT(NULL != pHdl);
    pTmp = pHdl-&gt;_next;
    _DoFree(pHdl);
  }
  UNLOCK;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-4-12" class="outline-5">
<h5 id="sec-1-2-4-12"><span class="section-number-5">1.2.4.12</span> CloneAndTerminate</h5>
<div class="outline-text-5" id="text-1-2-4-12">

<p>这个API的语义在之前已经解释过了，来看看代码.
</p>


<pre class="src src-C++">BufHandle* CloneAndTerminate(BufHandle* pHdl, BufHandle* pNext,
                             int* pnLen, bool bCopyNonTranBuf
                            ) {
  BufHandle* pFirst, *pTmp, **ppLast, **ppLastTmp;
  int nLen = 0;

  pFirst = NULL;
  ppLast = &amp;pFirst;
  LOCK;
  for ( ; pHdl != pNext; pHdl = pHdl-&gt;_next) {
    pTmp = _DoAddRef(pHdl, NULL, &amp;ppLastTmp); // &#30475;&#30475;&#26159;&#21542;&#21487;&#20197;&#22312;&#30452;&#25509;&#20570;&#24341;&#29992;&#35745;&#25968;.
    if (NULL == pTmp) {
      if (bCopyNonTranBuf) { // &#22914;&#26524;&#38656;&#35201;copy&#20986;&#26469;&#30340;&#35805;.
        UNLOCK;
        pTmp = AllocForBuf(pHdl-&gt;pBuf, pHdl-&gt;nDataLen, NULL, &amp;ppLastTmp);
        LOCK;
      } else { // &#22914;&#26524;&#26174;&#31034;&#35828;&#19981;copy&#21482;&#26159;&#24341;&#29992;&#20869;&#23384;&#30340;&#35805;,&#37027;&#20040;&#21482;&#26159;&#24320;&#36767;Handle&#23545;&#35937;.
        pTmp = TObjectPool&lt;BufHandle&gt;::Allocate();
        pTmp-&gt;pBuf = pHdl-&gt;pBuf;
        pTmp-&gt;nDataLen = pTmp-&gt;nBufLen = pHdl-&gt;nDataLen;
        pTmp-&gt;_next = NULL;
        ppLastTmp = &amp;pTmp-&gt;_next;
      }
    }
    nLen += pHdl-&gt;nDataLen;
    *ppLast = pTmp;
    ppLast = ppLastTmp;
  }
  UNLOCK;

  if (pnLen) {
    *pnLen = nLen;
  }
  if (nLen) {
    return pFirst;
  }
  // &#22914;&#26524;&#22833;&#36133;&#30340;&#35805;&#37027;&#20040;&#37322;&#25918;&#24050;&#32463;&#20998;&#37197;&#20986;&#26469;&#30340;.
  ChainFreeHdl(pFirst, NULL);
  return NULL;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><span class="section-number-4">1.2.5</span> Kylin</h4>
<div class="outline-text-4" id="text-1-2-5">

<p>这个模块主要负责框架的启动和停止，做了一些琐碎的事情方便用户，主要是下面这两个函数
</p>


<pre class="src src-C++">// &#21551;&#21160;&#26694;&#26550;&#65292;&#20351;&#29992;&#22810;&#23569;&#20010;CPU,&#32593;&#32476;&#21644;&#30913;&#30424;&#32447;&#31243;&#65292;&#33267;&#23569;1&#20010;CPU&#21644;1&#20010;&#32593;&#32476;&#32447;&#31243;
// f&#34920;&#31034;&#32447;&#31243;&#21021;&#22987;&#21270;&#20989;&#25968;
// nTimerPrecision&#20250;&#24433;&#21709;&#21040;&#23450;&#26102;&#22120;&#23454;&#29616;.&#22914;&#26524;&#36229;&#26102;&#22312;&#26102;&#38388;&#31934;&#24230;&#19968;&#19979;&#30340;&#35805;&#37117;&#20250;&#36890;&#36807;ExecMan&#30452;&#25509;&#35302;&#21457;
// &#21542;&#21017;&#37117;&#20250;&#24517;&#39035;&#36890;&#36807;RunTimer&#26469;&#36827;&#34892;&#26816;&#26597;
APF_ERROR InitKylin(int nExecWorkers, int nNetWorkers, int nDiskWorkers,
                    THREAD_INIT_PROC f, uint32 nTimerPrecision);
// bWait&#34920;&#31034;&#26159;&#21542;&#31561;&#24453;ExecMan&#30340;&#32447;&#31243;&#27744;&#27491;&#24120;&#20572;&#27490;&#65292;&#36825;&#20010;&#20250;&#22312;ExecMan&#37096;&#20998;&#25552;&#21040;
APF_ERROR StopKylin(bool bWait);
</pre>

<p>
对于InitKylin里面事情就是启动几个Manager，还做了一件tricky事情就是将SIGPIPE信号忽略了。而StopKylin就是停止这些Manager.我们需要仔细关注的就是这些Manager的启停。
</p>
</div>

</div>

<div id="outline-container-1-2-6" class="outline-4">
<h4 id="sec-1-2-6"><span class="section-number-4">1.2.6</span> ExecMan</h4>
<div class="outline-text-4" id="text-1-2-6">


</div>

<div id="outline-container-1-2-6-1" class="outline-5">
<h5 id="sec-1-2-6-1"><span class="section-number-5">1.2.6.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-2-6-1">

<p>我们首先看看ExecMan的接口
</p>


<pre class="src src-C++">#define g_pExecMan CExecMan::Instance() // &#30452;&#25509;&#20351;&#29992;&#23439;g_pExecMan&#23601;&#21487;&#20197;&#21333;&#20363;

class CExecMan
{
    DECLARE_SINGLETON(CExecMan) // &#21333;&#20363;&#27169;&#24335;
    public:
    ~CExecMan();
    APF_ERROR Start(int nWorkers, THREAD_INIT_PROC fInit, uint32 nTimerPrecision);
    void Stop(bool bWait);

    // &#25554;&#20837;&#19968;&#20010;&#20219;&#21153;
    APF_ERROR QueueExec(AsyncContext* pCtx, bool bClientReferred);
    // &#25554;&#20837;&#19968;&#20010;&#32039;&#24613;&#20219;&#21153;
    APF_ERROR QueueExecEmergent(AsyncContext* pCtx, bool bClientReferred);
    // TODO(zhangyan04):
    APF_ERROR ProxyExec(int nAckCode, CAsyncClient* pClient, PROXY_EXEC_PROC fProc, ProxyExecCtx* pCtx);
    // &#25552;&#20132;&#19968;&#20010;&#23450;&#26102;&#22120;&#20219;&#21153;
    APF_ERROR DelayExec(int nAction, CAsyncClient* pClient, uint32 nMilliseconds, AsyncContext* pCtx);
    // &#21462;&#28040;&#19968;&#20010;&#20219;&#21153;
    APF_ERROR CancelExec(AsyncContext* pCtx);
    // &#26816;&#26597;&#23450;&#26102;&#22120;
    void RunTimer();

  private:
    CThreadPool m_ThreadPool;
    volatile int m_nCurJobs; // &#22312;&#36816;&#34892;&#26399;&#38388;&#26377;&#22810;&#23569;Job&#27491;&#22312;&#34987;&#25552;&#20132;
};
</pre>


</div>

</div>

<div id="outline-container-1-2-6-2" class="outline-5">
<h5 id="sec-1-2-6-2"><span class="section-number-5">1.2.6.2</span> Start &amp; Stop</h5>
<div class="outline-text-5" id="text-1-2-6-2">

<p>Start逻辑很简单，包括计算1s对应多少cycle数目以及启动线程池。
</p>


<pre class="src src-C++">APF_ERROR CExecMan::Start(int nWorkers, THREAD_INIT_PROC fInit, uint32 nTimerPrecision)
{
    // &#35745;&#31639;&#19968;&#19979;CPU&#19968;&#20010;tick&#26377;&#22810;&#23569;&#20010;cycle&#25968;&#30446;&#65292;&#36825;&#26679;&#21487;&#20197;&#36890;&#36807;rdstc&#36716;&#25442;&#25104;&#20026;&#26102;&#38388;
    g_nCycleStart = rdtsc();
    g_nLastTick = 0;
    g_nTickPrecision = (nTimerPrecision &gt;= 1000) ? 1000 : nTimerPrecision;
    g_nCyclesInTick = GetCpuFreq() / (1000 / g_nTickPrecision);
    if (0 &lt; m_ThreadPool.Start(nWorkers, fInit)) { // &#21551;&#21160;&#32447;&#31243;&#27744;
        AtomicSetValue(m_nCurJobs, 0);
        return APFE_OK;
    }
    return APFE_SYS_ERROR;
}
</pre>


<p>
Stop逻辑的话可能需要仔细理解一下
</p>


<pre class="src src-C++">// bWait&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#31561;&#24453;kylin&#30340;&#32447;&#31243;&#27744;&#27491;&#24120;&#32467;&#26463;&#65292;&#25191;&#34892;&#23436;&#25104;&#32447;&#31243;&#27744;&#37324;&#38754;&#20219;&#21153;&#20026;&#27490;&#12290;
// &#19981;&#26029;&#20462;&#27491;m_nCurJobs&#20316;&#29992;&#26159;&#20026;&#20102;&#38459;&#27490;&#26032;&#20219;&#21153;&#30340;&#25552;&#20132;&#12290;&#36825;&#20010;&#25105;&#20204;&#21487;&#20197;&#22312;QueuExec&#37096;&#20998;&#32852;&#21512;&#36215;&#26469;&#19968;&#36215;&#30475;&#30475;
void CExecMan::Stop(bool bWait)
{
    if (bWait) {
        int n;
        while (0 != (n=atomic_comp_swap(&amp;m_nCurJobs, LARGE_ENOUGH_NEGATIVE, 0))) {
            if (LARGE_ENOUGH_NEGATIVE == n) {
                return;
            }
            Sleep(1);
        }
        m_ThreadPool.Stop();
    }
    else {
        AtomicSetValue(m_nCurJobs, LARGE_ENOUGH_NEGATIVE);
    }
}
</pre>


</div>

</div>

<div id="outline-container-1-2-6-3" class="outline-5">
<h5 id="sec-1-2-6-3"><span class="section-number-5">1.2.6.3</span> QueueExec</h5>
<div class="outline-text-5" id="text-1-2-6-3">

<p>QueueExec和QueueExecEmergent逻辑非常相似，只不过底层调用线程池的QueueJob和QueueEmergentJob.我们这里只看QueueExec.
</p>


<pre class="src src-C++">static void
Proc(Job* pJob)
{
    AsyncContext* pCtx = (AsyncContext*)pJob;
    CAsyncClient* pClient = pCtx-&gt;pClient;

    pCtx-&gt;fProc = NULL;
    pClient-&gt;OnCompletion(pCtx);
    pClient-&gt;Release();
}

// bClientReferref&#34920;&#26126;&#29992;&#25143;&#26159;&#21542;&#21152;&#20102;&#24341;&#29992;
// &#22914;&#26524;&#25353;&#29031;sunxiao&#30340;&#35828;&#26126;&#65292;&#25105;&#20204;&#36825;&#37324;&#26368;&#22909;&#27704;&#36828;&#20889;true,&#28982;&#21518;&#25105;&#20204;&#22312;&#22806;&#38754;&#35843;&#29992;&#28857;&#33258;&#24049;AddRef&#21644;DecRef
APF_ERROR CExecMan::QueueExec(AsyncContext* pCtx, bool bClientReferred)
{
    VERIFY_OR_RETURN(NULL != pCtx, APFE_INVALID_ARGS);
    VERIFY_OR_RETURN(NULL != pCtx-&gt;pClient, APFE_INVALID_ARGS);

    // &#22914;&#26524;atomic +1 &lt;0&#30340;&#35805;&#65292;&#37027;&#20040;&#35828;&#26126;&#36825;&#20010;&#26102;&#20505;m_nCurJobs&#24050;&#32463;&#34987;&#32622;&#36807;LARGE_ENOUGH_NEGATIVE&#20102;
    // &#24403;&#28982;&#25105;&#20204;&#26159;&#26377;&#20551;&#35774;m_nCurJobs&#19981;&#20250;&#38750;&#24120;&#24555;&#22320;&#22797;&#20301;&#65292;&#21487;&#20197;&#35748;&#20026;&#36825;&#20010;&#26159;&#25104;&#31435;&#30340;
    if (atomic_add(&amp;m_nCurJobs, 1) &gt;= 0) {
        // TODO: if the number of workers is dynamic, we may need to lock and re-dispatch exisiting events...
        if (!bClientReferred) {
            pCtx-&gt;pClient-&gt;AddRef();
        }
        pCtx-&gt;fProc = Proc; // &#32622;ctx&#30340;fProc&#20026;Proc
        // &#28982;&#21518;&#26681;&#25454;client&#30340;AsyncId&#26469;&#20915;&#23450;&#25351;&#27966;&#21040;&#21738;&#19968;&#20010;&#32447;&#31243;&#24037;&#20316;
        m_ThreadPool.QueueJob((Job*)pCtx, pCtx-&gt;pClient-&gt;GetAsyncId() % m_ThreadPool.GetWorkerCount());
        atomic_add(&amp;m_nCurJobs, -1); // &#23558;&#24403;&#21069;&#27491;&#22312;&#25552;&#20132;&#30340;Jobs&#20010;&#25968;-1.
        return APFE_OK;
    }
    if (bClientReferred) {
        pCtx-&gt;pClient-&gt;Release();
    }
    // &#37027;&#20040;&#23558;m_nCurJobs&#37325;&#32622;
    AtomicSetValue(m_nCurJobs, LARGE_ENOUGH_NEGATIVE);
    if (IsKylinRunning()) {
        TRACE0(<span class="org-string">"Fatal error: Exec workers are not started\n"</span>);
    }
    return APFE_NO_WORKER;
}
</pre>

<p>
我们这里可以看到m_nCurJobs在QueueExec和Stop之间的配合。然后我们稍微看看Proc这个过程，对于CPU任务直接调用OnCompletion然后调用Release.
</p>
</div>

</div>

<div id="outline-container-1-2-6-4" class="outline-5">
<h5 id="sec-1-2-6-4"><span class="section-number-5">1.2.6.4</span> Timer</h5>
<div class="outline-text-5" id="text-1-2-6-4">

<p>定时器任务加入是DelayExec,检查触发是RunTimer.如果查看CallGraph的话会发现RunTimer都是在网络部分调用的，我们在网络部分看看触发的时机。
DelayExec里面的逻辑会根据定时时间来判断如何实现，如果定时时间超过g_nTickPrecision，那么会将超时时间加入一个map里面去，然后让RunTimer去触发。
否则会加入线程池里面去。对于加入到map里面的fProc有一个特殊的标记(JOB_PROC)2.在CancelExec时候会认识这个特殊标记，将事件从map中删除。
</p>


<pre class="src src-C++">APF_ERROR CExecMan::DelayExec(int nAction, CAsyncClient* pClient, uint32 nMilliseconds, AsyncContext* pCtx)
{
    VERIFY_OR_RETURN(NULL != pClient, APFE_INVALID_ARGS);
    VERIFY_OR_RETURN(NULL != pCtx, APFE_INVALID_ARGS);

    pCtx-&gt;nAction = nAction;
    pCtx-&gt;pClient = pClient;
    pCtx-&gt;fProc = (JOB_PROC)2;

    if (g_nTickPrecision &lt;= nMilliseconds) {
        pClient-&gt;AddRef();

        s_Lock.Lock();
        /* milliseconds -&gt; ticks */
        nMilliseconds = g_nLastTick + nMilliseconds / g_nTickPrecision;
        pCtx-&gt;nErrCode = nMilliseconds;
        s_TimerMap.insert(nMilliseconds, pCtx);
        s_Lock.Unlock();
        return APFE_OK;
    }

    APF_ERROR err;
    s_Lock.Lock();
    err = QueueExec(pCtx, false);
    s_Lock.Unlock();
    return err;
}
</pre>


<p>
然后我看看看RunTimer这个部分。这个部分非常简单，就是根据当前时间判断map里面哪些定时器需要进行触发，然后将触发逻辑作为Job丢入CPU线程池。
我们这里不看RunTimer具体代码，反而倒是对外面的一些小细节比较感兴趣。我们不希望RunTimer被多个实例调用，只要有一个实例调用就OK，使用CToken完成。
当然可以使用mutex+try_lock来实现但是开销应该会更大。
</p>


<pre class="src src-C++">void CExecMan::RunTimer()
{
    static CToken token;
    UNLIKELY_IF (!token.TryAcquire(1)) {
        return;
    }
    // ...
    token.Release(1);
}
</pre>


</div>

</div>

<div id="outline-container-1-2-6-5" class="outline-5">
<h5 id="sec-1-2-6-5"><span class="section-number-5">1.2.6.5</span> Example</h5>
<div class="outline-text-5" id="text-1-2-6-5">

<p>我们这里给的例子非常简单，但是希望有启发性.我们从1开始进行打印，每打印1个数字就认为当前任务结束，一直无限打印。
但是我们同时会启动一个定时器，只允许我们做1.2s钟时间的打印。如果我们在1.2s内打印数字个数超过了100个的话，那么我们重启一个定时器1.2s，
而这次打印数字个数阈值为200个之后每次翻倍，直到1.2s内没有打印我们所希望个数的话程序退出。在主线程100ms来检查ExecMan的RunTimer.
</p>


<pre class="src src-C++">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;time.h&gt;
#include <span class="org-string">"stdafx.h"</span>
#include <span class="org-string">"Kylin.h"</span>

static volatile int worker=16;
static const int PRINT=0;
static const int TIMEOUT=1;
static const int TIMEOUT_MS=1200;

class XAsyncClient:public CAsyncClient{
  public:
    AsyncContext print_ctx;
    AsyncContext delay_ctx;
    int id;
    int current_number;
    int threshold;
    int last_working_number;
    bool stop; // &#19968;&#26086;stop&#37027;&#20040;&#31435;&#21051;&#21518;&#38754;&#20869;&#23481;&#37117;&#19981;&#25171;&#21360;&#20102;
    XAsyncClient(int id_):
            id(id_),
            current_number(1),
            threshold(100),
            last_working_number(0),
            stop(false){
        InitAsyncContext(&amp;print_ctx);
        InitAsyncContext(&amp;delay_ctx);
        print_ctx.pClient=this;
        delay_ctx.pClient=this;
    }
    int Release(){ // Release&#36890;&#24120;&#37117;&#26159;&#36825;&#26679;&#20889;&#30340;
        int n=CAsyncClient::Release();
        if(n==0){
            delete this;
        }
        return n;
    }
    void Start(){ // &#21551;&#21160;&#26102;&#20505;&#25105;&#20204;&#21457;&#36215;&#20004;&#20010;Job
        print_ctx.nAction=PRINT;
        CAsyncClient::AddRef();
        g_pExecMan-&gt;QueueExec(&amp;print_ctx,true);
        CAsyncClient::AddRef();
        g_pExecMan-&gt;DelayExec(TIMEOUT,this,TIMEOUT_MS,&amp;delay_ctx);
    }
    void Print(){
        fprintf(stderr,<span class="org-string">"(%d)xref:%d,current:%d\n"</span>,id,CAsyncClient::GetRef(),
                current_number);
    }
    virtual void OnCompletion(AsyncContext* ctx){
        switch(ctx-&gt;nAction){ // &#20998;&#21035;&#22788;&#29702;&#36825;&#20004;&#20010;&#31867;&#22411;Job
            case PRINT:
                if(stop){
                    break;
                }
                fprintf(stderr,<span class="org-string">"(%d)%d\n"</span>,id,current_number);
                current_number++;
                if((current_number-last_working_number)&gt;=threshold){
                    // update
                    last_working_number=current_number;
                    threshold*=2;
                    // canel timer.
                    fprintf(stderr,<span class="org-string">"(%d)==============================restart timer==============================\n"</span>,id);
                    g_pExecMan-&gt;CancelExec(&amp;delay_ctx);
                    g_pExecMan-&gt;DelayExec(TIMEOUT,this,TIMEOUT_MS,&amp;delay_ctx);
                }
                CAsyncClient::AddRef();
                g_pExecMan-&gt;QueueExec(&amp;print_ctx,true);
                break;
            case TIMEOUT:
                fprintf(stderr,<span class="org-string">"(%d)********************quit********************\n"</span>,id);
                atomic_add(&amp;worker,-1);
                stop=true;
                break;
            default:
                assert(0);
        }
    }
};

int main(){
    // use 4 exec threads.
    InitKylin(4,0,0);
    // 100ms
    const struct timespec spec={0,100*1000000};
    const int worker_num=worker;
    std::vector&lt; XAsyncClient* &gt; vec;
    for(int i=0;i&lt;worker_num;i++){
        XAsyncClient* client=new XAsyncClient(i);
        vec.push_back(client);
        client-&gt;Start();
    }
    while(1){
        nanosleep(&amp;spec,NULL);
        //Sleep(1);
        if(AtomicGetValue(worker)==0){
            StopKylin(true);
            break;
        }else{ // &#20027;&#32447;&#31243;&#25105;&#20204;&#27599;&#38548;100ms&#26816;&#26597;&#19968;&#27425;&#36229;&#26102;&#24773;&#20917;
            g_pExecMan-&gt;RunTimer();
        }
    }
    for(int i=0;i&lt;worker_num;i++){
        XAsyncClient* client=vec[i];
        client-&gt;Print(); // &#36864;&#20986;&#26102;&#20505;&#25171;&#21360;&#19968;&#19979;&#20449;&#24687;
        delete client;
    }
    return 0;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-2-7" class="outline-4">
<h4 id="sec-1-2-7"><span class="section-number-4">1.2.7</span> DiskMan</h4>
<div class="outline-text-4" id="text-1-2-7">


</div>

<div id="outline-container-1-2-7-1" class="outline-5">
<h5 id="sec-1-2-7-1"><span class="section-number-5">1.2.7.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-2-7-1">

<p>我们首先看看和磁盘相关的两个比较重要的类。因为磁盘操作不像CPU操作一样不需要任何辅助数据结构，磁盘操作需要一些信息比如fd等，磁盘操作需要一个特殊的磁盘Context。
然后每次发起磁盘操作使用另外一个结构Request.这里名字上和原来的CPU事件并不太一样，我们可能需要习惯一下。实际上如果我们需要映射到CPU事件里面的话，这两个Context应该结合在一起。
只不过这里DiskContext不是经常变动的部分，而DiskRequest是经常变动的部分所以分离开了。
</p>



<pre class="src src-C++">// &#36825;&#20010;&#26159;&#30913;&#30424;&#25805;&#20316;&#30456;&#20851;&#30340;Context
struct DiskContext {
    int fd;
    int diskno;// which disk
    CAsyncClient *pClient;
    uint64 nCurOff, nRead, nWrite;
    char* pPath;// file path
    int nFlag;// file open flag
};

// &#36825;&#20010;&#26159;&#19968;&#27425;&#21457;&#36215;&#30340;&#35831;&#27714;
struct DiskRequest {
    union { // &#36825;&#37324;&#20351;&#29992;&#36825;&#31181;&#26041;&#24335;&#32431;&#31929;&#26159;&#20026;&#20102;&#20889;&#36215;&#26469;&#26041;&#20415;
        AsyncContext async;
        Job job;
    };
    /* !!the first element must be AsyncContext */
    void *buf; // &#35835;&#20889;&#25918;&#21040;&#20160;&#20040;&#22320;&#26041;
    int request; // &#35835;&#20889;&#22810;&#23569;&#23383;&#33410;&#25968;&#25454;
    int xfered; //&#24403;&#21069;&#23454;&#38469;&#35835;&#20889;&#20102;&#22810;&#23569;&#25968;&#25454;
    uint64 off; // &#22312;&#20160;&#20040;&#20559;&#31227;&#19978;&#35835;&#20889;
    DiskContext *pCtx;
};
</pre>

<p>
然后在看看DiskMan接口
</p>


<pre class="src src-C++">#define g_pDiskMan CDiskMan::Instance() // &#30452;&#25509;&#20351;&#29992;&#23439;g_pDiskMan&#23601;&#21487;&#20197;&#21333;&#20363;

class CDiskMan
{
    DECLARE_SINGLETON(CDiskMan) // &#21333;&#20363;&#27169;&#24335;
    public:
    ~CDiskMan();

    APF_ERROR Start(int nDisks, THREAD_INIT_PROC fInit);
    void Stop();

    APF_ERROR Associate(int diskno, int fd, CAsyncClient* pClient, DiskContext* pContext);
    APF_ERROR Associate(int diskno, char* pPath, int nFlag, CAsyncClient* pClient, DiskContext* pContext);
    APF_ERROR Deassociate(DiskContext* pContext);

    void Read(DiskContext* pContext, void* pBuf, int count, DiskRequest* pReq);
    void Write(DiskContext* pContext, void* pBuf, int count, DiskRequest* pReq);

  private:
    CThreadPool m_ThreadPool;
    bool m_bStarted;
};
</pre>


</div>

</div>

<div id="outline-container-1-2-7-2" class="outline-5">
<h5 id="sec-1-2-7-2"><span class="section-number-5">1.2.7.2</span> Start &amp; Stop</h5>
<div class="outline-text-5" id="text-1-2-7-2">

<p>启动停止逻辑非常简单，就是让线程池启动和停止
</p>


<pre class="src src-C++">APF_ERROR CDiskMan::Start(int nDisks, THREAD_INIT_PROC fInit)
{
    ASSERT(nDisks &lt;= MAX_NR_DISKS);
    ASSERT(!IsStarted());
    // TODO::: if 0 then check the number of disks
    if (m_ThreadPool.Start(nDisks, fInit) &gt; 0) {
        m_bStarted = true;
        return APFE_OK;
    }
    return APFE_SYS_ERROR;
}

void CDiskMan::Stop()
{
    if (m_bStarted) {
        m_bStarted = false;
        m_ThreadPool.Stop();
    }
}
</pre>


</div>

</div>

<div id="outline-container-1-2-7-3" class="outline-5">
<h5 id="sec-1-2-7-3"><span class="section-number-5">1.2.7.3</span> Associate &amp; Deassociate</h5>
<div class="outline-text-5" id="text-1-2-7-3">

<p>逻辑非常简单，就是进行一下DiskContext和CAsyncClient初始化的工作。关于DiskContext里面各个字段含义的话，都是在Read/Write时候解释的。
关于这里最重点的绑定内容就是diskno.diskno非常作用类似于CPU事件里面的AsyncId.相同AsyncId可以分摊到同一个CPU线程这件可以免去加锁开销，
而diskno可以让多个DiskContext分摊到同一个Disk线程，不同线程绑定不同的磁盘驱动器，这样可以让同一个磁盘驱动器仅仅为几个文件服务。
</p>



<pre class="src src-C++">APF_ERROR CDiskMan::Associate(int diskno, char* pPath, int nFlag,
                              CAsyncClient* pClient, DiskContext* pContext)
{
    pContext-&gt;fd = -1;
    pContext-&gt;diskno = diskno;
    pContext-&gt;pClient = pClient;
    pContext-&gt;nCurOff = pContext-&gt;nRead = pContext-&gt;nWrite = 0;
    pContext-&gt;pPath = pPath;
    pContext-&gt;nFlag = nFlag;
    pClient-&gt;AddRef();
    return APFE_OK;
}

APF_ERROR CDiskMan::Deassociate(DiskContext* pContext)
{
    if (pContext-&gt;pPath &amp;&amp; pContext-&gt;fd!=-1) {
        close(pContext-&gt;fd);
    }
    pContext-&gt;pClient-&gt;Release();
    return APFE_OK;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-7-4" class="outline-5">
<h5 id="sec-1-2-7-4"><span class="section-number-5">1.2.7.4</span> Read &amp; Write</h5>
<div class="outline-text-5" id="text-1-2-7-4">

<p>文件的Read/Write非常简单，因为本身就是一个阻塞的过程，发起一次就可以保证读取所有内容了，所以不像网络一样需要多次发起。
</p>


<pre class="src src-C++">void CDiskMan::Read(DiskContext* pContext, void* pBuf, int count, DiskRequest* pReq)
{
    pReq-&gt;async.nAction = AA_READ; // &#35774;&#32622;nAction,&#28982;&#21518;QueueTask,Task&#20013;&#22238;&#35843;&#23601;&#26159;ReadOp
    QUEUE_TASK(pContext, pReq, ReadOp, pBuf, count);
}

void CDiskMan::Write(DiskContext* pContext, void* pBuf, int count, DiskRequest* pReq)
{
    pReq-&gt;async.nAction = AA_WRITE; // &#35774;&#32622;nAction,&#28982;&#21518;QueueTask,Task&#20013;&#22238;&#35843;&#23601;&#26159;WriteOp
    QUEUE_TASK(pContext, pReq, WriteOp, pBuf, count);
}

// &#21487;&#20197;&#30475;&#21040;&#36825;&#37324;pClient&#24050;&#32463;&#24110;&#25105;&#20204;AddRef&#20102;&#65292;&#25152;&#20197;&#25105;&#20204;&#22312;&#23454;&#38469;&#32534;&#20889;App&#19981;&#38656;&#35201;&#20877;&#27425;AddRef
#define QUEUE_TASK(pContext, pReq, f, pBuf, count)                  \
    pContext-&gt;pClient-&gt;AddRef();                                    \
    pReq-&gt;async.pClient = pContext-&gt;pClient;                        \
    pReq-&gt;job.fProc = f;                                            \
    pReq-&gt;buf = pBuf;                                               \
    pReq-&gt;request = count;                                          \
    pReq-&gt;xfered = 0;                                               \
    pReq-&gt;pCtx = pContext;                                          \
    m_ThreadPool.QueueJob(&amp;pReq-&gt;job, pContext-&gt;diskno)
</pre>


<p>
从上面分析的话，所有重要的工作都分摊在了ReadOp和WriteOp上面。我们需要做的是Dig下去看看两个是怎么工作的。但是很不幸，两个函数里面内容都是使用了宏DiskOp.
DiskOp(a,b,c)其中a表示对应的系统调用叫什么名字，b表示这个Job,c表示读写(没有使用).
</p>


<pre class="src src-C++">static void
ReadOp(Job* pJob)
{
    DISK_OP(read, pJob, 0);
}

static void
WriteOp(Job* pJob)
{
    DISK_OP(write, pJob, 1);
}
</pre>


<p>
继续Dig看看DISKOP是怎么工作的
</p>


<pre class="src src-C++">// &#23436;&#25104;&#20043;&#21518;&#35774;&#32622;ErrCode,&#24182;&#19988;&#21152;&#20837;CPU&#32447;&#31243;&#27744;&#12290;&#29992;&#25143;&#26368;&#32456;&#22788;&#29702;&#30340;&#35805;&#38656;&#35201;&#24378;&#21046;&#36716;&#25442;DiskRequest.
#define NotifyClient(err, req)    {                                     \
        req-&gt;async.nErrCode = err;                                      \
        g_pExecMan-&gt;QueueExec((AsyncContext*)req, true);                \
    }

// 1.&#21487;&#20197;&#30475;&#21040;&#22914;&#26524;fd==-1&#30340;&#35805;&#20250;&#33258;&#21160;&#25171;&#24320;&#25991;&#20214;
// 2.&#21028;&#26029;&#19968;&#19979;&#21457;&#36215;&#30340;off&#21644;context&#26159;&#21542;&#19968;&#33268;&#65292;&#19981;&#19968;&#33268;&#30340;&#35805;&#20351;&#29992;pread/pwrite,&#28982;&#21518;&#20462;&#25913;off
// 3.&#35835;&#21462;&#23436;&#25104;&#20043;&#21518;&#20351;&#29992;NotifyClient&#36890;&#30693;App
#define DISK_OP(op, j, rw)                                              \
    DiskRequest* pReq = CONTAINING_RECORD(j, DiskRequest, job);         \
    DiskContext* pCtx = pReq-&gt;pCtx;                                     \
    UNLIKELY_IF (-1 == pCtx-&gt;fd) {                                      \
        pCtx-&gt;fd = open(pCtx-&gt;pPath, pCtx-&gt;nFlag, 0644);                \
        UNLIKELY_IF (-1 == pCtx-&gt;fd) {                                  \
            NotifyClient(errno, pReq);                                  \
            return;                                                     \
        }                                                               \
    }                                                                   \
    uint64 cost = rdtsc();                                              \
    int len;                                                            \
    if (pReq-&gt;off != pCtx-&gt;nCurOff) {                                   \
        len = p ## op(pCtx-&gt;fd, pReq-&gt;buf, pReq-&gt;request, pReq-&gt;off);   \
        pCtx-&gt;nCurOff = pReq-&gt;off;                                      \
    }                                                                   \
    else {                                                              \
        len = op(pCtx-&gt;fd, pReq-&gt;buf, pReq-&gt;request);                   \
    }                                                                   \
    if (len &gt;= 0) {                                                     \
        cost = rdtsc() - cost;                                          \
        int which = (pCtx-&gt;diskno&lt;&lt;1) + rw;                             \
        g_nDiskStats[which] += len;                                     \
        g_nDiskCosts[which] += cost;                                    \
        pCtx-&gt;nCurOff += len;                                           \
        pReq-&gt;off += len;                                               \
        pReq-&gt;xfered = len;                                             \
        NotifyClient(0, pReq);                                          \
    }                                                                   \
    else {                                                              \
        NotifyClient(errno, pReq);                                      \
    }
</pre>


</div>

</div>

<div id="outline-container-1-2-7-5" class="outline-5">
<h5 id="sec-1-2-7-5"><span class="section-number-5">1.2.7.5</span> Example</h5>
<div class="outline-text-5" id="text-1-2-7-5">

<p>例子非常简单就是我们首先发起一个磁盘操作写文件然后在将去读取出来。
</p>


<pre class="src src-C++">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;time.h&gt;
#include <span class="org-string">"stdafx.h"</span>
#include <span class="org-string">"Kylin.h"</span>

static const int worker_num=8;
static volatile int worker=worker_num;
static const char* fname_prefix=<span class="org-string">"hello"</span>;
static const char* content=<span class="org-string">"world"</span>;
static const int READ=0;
static const int WRITE=1;
static const int disk_thread_num=4;

class XDiskRequest:public DiskRequest{
  public:
    int nAction; // what kind of operation we init.
};

class XAsyncClient:public CAsyncClient{
  public:
    int id;
    std::string name;
    DiskContext disk_ctx;
    XDiskRequest disk_req;
    XAsyncClient(int id_):
            id(id_){
        // make filename.
        char tmp[128];
        snprintf(tmp,sizeof(tmp),<span class="org-string">"%s_%d"</span>,fname_prefix,id);
        name=tmp;
        g_pDiskMan-&gt;Associate(id%disk_thread_num,const_cast&lt;char*&gt;(name.c_str()),O_RDWR | O_CREAT,this,&amp;disk_ctx);
    }
    ~XAsyncClient(){
        g_pDiskMan-&gt;Deassociate(&amp;disk_ctx);
    }
    void Start(){
        disk_req.nAction=WRITE;
        char* s=strdup(content);
        // ctx off=0.write from the beginning
        g_pDiskMan-&gt;Write(&amp;disk_ctx,s,strlen(s)+1,&amp;disk_req);
    }
    void Print(){
        fprintf(stderr,<span class="org-string">"(%d)xref:%d\n"</span>,id,CAsyncClient::GetRef());
    }
    virtual void OnCompletion(AsyncContext* ctx){
        XDiskRequest* req=(XDiskRequest*)ctx;
        if(req-&gt;nAction==WRITE){
            assert(req-&gt;xfered==req-&gt;request);
            // free written buffer.
            free(req-&gt;buf);
            // begin to read.
            disk_req.nAction=READ;
            disk_req.off=0; // read from beginning
            char* s=(char*)malloc(req-&gt;request);
            g_pDiskMan-&gt;Read(&amp;disk_ctx,s,req-&gt;request,&amp;disk_req);
        }else if(req-&gt;nAction==READ){
            assert(req-&gt;xfered==req-&gt;request);
            fprintf(stderr,<span class="org-string">"(%d)%s\n"</span>,id,req-&gt;buf);
            // free read buffer.
            free(req-&gt;buf);
            atomic_add(&amp;worker,-1);
        }
    }
};

int main(){
    // use 4 disk threads.
    InitKylin(1,1,disk_thread_num);
    std::vector&lt; XAsyncClient* &gt; vec;
    for(int i=0;i&lt;worker_num;i++){
        XAsyncClient* client=new XAsyncClient(i);
        vec.push_back(client);
        client-&gt;Start();
    }
    // 100ms.
    const struct timespec timeout={0,100*1000000};
    while(1){
        nanosleep(&amp;timeout,NULL);
        if(AtomicGetValue(worker)==0){
            StopKylin(true);
            break;
        }
    }
    for(int i=0;i&lt;worker_num;i++){
        XAsyncClient* client=vec[i];
        client-&gt;Print();
        delete client;
    }
    return 0;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-2-8" class="outline-4">
<h4 id="sec-1-2-8"><span class="section-number-4">1.2.8</span> NetworkMan</h4>
<div class="outline-text-4" id="text-1-2-8">


</div>

<div id="outline-container-1-2-8-1" class="outline-5">
<h5 id="sec-1-2-8-1"><span class="section-number-5">1.2.8.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-2-8-1">

<p>和网络相关的也有两个比较重要的类。同样和DiskMan相同，NetworkMan也提供了NetContext和NetRequest.
</p>


<pre class="src src-C++">// &#32593;&#32476;&#35831;&#27714;
struct NetRequest {
    union {
        AsyncContext async;
        DLINK link;
    };
    /* !! the first element must be AsyncContext */
    union {
        BufHandle hdl;
        struct {
            BufHandle *pHdl;    // not used by read
            void* buf;
            int len;            // buffer len
            int request;        // request len
        };
    };
    int xfered; // &#24050;&#32463;&#35835;&#21462;&#20102;&#22810;&#23569;&#20010;&#23383;&#33410;
    uint32 ip;                  // for UDP
    uint16 port;                // for UDP
};

// Socket&#30456;&#20851;&#29366;&#24577;
enum SocketState {
    SS_VOID = 0,
    SS_LISTENING_0,
    SS_LISTENING,
    SS_CONNECTING_0,
    SS_CONNECTING,
    SS_CONNECTED_0,
    SS_CONNECTED,
    SS_ERROR,
    SS_SHUTDOWN,
};

// Socket Flag
enum SocketFlag {
    SF_DIRECT_CALLBACK  = 0x1, // &#22788;&#29702;&#23436;&#25104;&#20043;&#21518;&#22238;&#35843;&#20989;&#25968;&#30452;&#25509;&#22312;Network&#32447;&#31243;&#25191;&#34892;&#32780;&#19981;&#20002;&#21040;CPU&#32447;&#31243;
    SF_PERMANENT        = 0x2, // TODO(zhangyan04):???
    SF_UDP              = 0x4, // &#20351;&#29992;UDP&#21327;&#35758;
    SF_DONT_EXHAUST     = 0x8, // TODO(zhangyan04):???
};

// &#32593;&#32476;&#30456;&#20851;&#25805;&#20316;&#30340;Context
struct NetContext {
    SOCKET s; // &#32593;&#32476;socket
    SocketState state; // socket&#29366;&#24577;

    DLINK link;                 // to link all active sockets
    CLockedInt tWrite, tRead; // TODO(zhangyan04):???
    TranQueue qRead, qWrite; // &#35835;&#20889;&#35831;&#27714;&#38431;&#21015;&#65292;push_back&#21644;pop_front&#38656;&#35201;&#21152;&#38145;&#20294;&#26159;&#19981;&#29992;&#31561;&#24453;&#12290;
    NetRequest *pReadReq, *pWriteReq; // &#24403;&#21069;&#35835;&#20889;&#35831;&#27714;
    BufHandle wHdl; // &#20889;BufHandle,StartWrite&#37324;&#38754;&#22810;&#27425;&#20889;&#30340;&#35805;&#24403;&#21069;BufHandle&#23601;&#20445;&#23384;&#22312;&#36825;&#37324;&#12290;
    // nDelayRead&#34920;&#31034;&#26159;&#21542;&#24050;&#32463;&#21457;&#29983;&#20102;Delay&#25805;&#20316;&#65292;&#19981;&#20801;&#35768;&#22810;&#27425;&#21457;&#36215;Delay&#25805;&#20316;
    // nEnabled&#34920;&#31034;&#24403;&#21069;Context&#26159;&#21542;&#21487;&#29992;
    volatile int nDelayRead, nEnabled;
    uint32 nTimeout; // &#36229;&#26102;&#26102;&#38388;
    uint64 tTimeoutCycle; // &#36229;&#26102;&#26102;&#38388;&#36716;&#25442;&#25104;&#20026;&#30340;cycle,&#31867;&#20284;&#20110;&#19968;&#20010;&#32477;&#23545;&#30340;&#36229;&#26102;&#26102;&#38388;

    CAsyncClient *pClient; // &#20851;&#32852;&#30340;client
    CEPoller* pPoller; // &#24213;&#23618;poller
    uint32 flag; // socket flag

    union {
        struct {                    // for connect
            uint32 ip;
            uint16 port;
        };
        uint32 backlog;             // for listen  // listen&#30340;bakclog
    };
};
</pre>

<p>
然后我们看看NetworkMan的接口
</p>


<pre class="src src-C++">#define g_pNetworkMan       CNetworkMan::Instance() // &#21333;&#20363;

typedef TLockedQueue&lt;NetContext, TStlList&lt;NetContext*&gt; &gt; NetContexts;
class CNetworkMan
{
    DECLARE_SINGLETON(CNetworkMan) // &#21333;&#20363;
    public:
    ~CNetworkMan();

    APF_ERROR Start(int nWorkers, THREAD_INIT_PROC fInit);
    void Stop();

    APF_ERROR Associate(NetContext* pCtx);
    APF_ERROR Deassociate(NetContext* pCtx);

    void Listen(NetContext* pCtx, int backlog);
    void Connect(NetContext* pCtx, uint32 ip, uint16 port, void *pWriteBuf,
                 int nWriteCount, uint32 timeout, NetRequest* pReq);
    void Monitor(NetContext* pCtx);
    bool Delay(NetContext* pCtx, uint32 nMilliseconds);

    void Read(NetContext* pCtx, void* pBuf, int len, int request, NetRequest* pReq);
    void Write(NetContext* pCtx, void* pBuf, int count, NetRequest* pReq);

    void Read(NetContext* pCtx, NetRequest* pReq);
    void Write(NetContext* pCtx, NetRequest* pReq);

  private:
    CThreadPool m_ThreadPool;
    volatile int m_bStarted;
    NetContexts m_NetContexts; // &#31649;&#29702;&#30340;NetContext
};
</pre>

<p>
虽然这个部分叫做NetworkMan,但是里面比较重要的逻辑部分都放在了EPoller里面来完成的，对于NetworkMan只不过是一个发起者的角色罢了。
对于NetworkMan部分的话还需要关注的是SocketState这个东西，因为对于EPoller来说的话只能够发现Socket究竟是可读还是可写，
我们必须根据SocketState来判断下一步应该进行什么操作。在最后的的话我们会给出SocketState的每个状态解释。
</p>
</div>

</div>

<div id="outline-container-1-2-8-2" class="outline-5">
<h5 id="sec-1-2-8-2"><span class="section-number-5">1.2.8.2</span> Start &amp; Stop</h5>
<div class="outline-text-5" id="text-1-2-8-2">

<p>过程大致是这样的，将EPoller.Run包装在一个MyJob对象里面，然后将MyJob丢入到线程池里面进行运行。一旦线程池取到MyJob,
调用的函数是EPoller.run方法。也就是说每个队列里面始终只有1个Job，所以在Stop时候我们只需要将EPoller.Close()就可以了。
</p>



<pre class="src src-C++">APF_ERROR CNetworkMan::Start(int nWorkers, THREAD_INIT_PROC fInit)
{
    int n = m_ThreadPool.Start(nWorkers, fInit);
    if (n &gt; 0) {
        for (int i=0; i&lt;n; i++) { // &#36825;&#37324;s_Jobs&#26159;&#38745;&#24577;&#23545;&#35937;
            s_Jobs[i].poller.Create(256);
            s_Jobs[i].job.fProc = Polling;
            s_Jobs[i].count = 0;
            DLINK_INITIALIZE(&amp;s_Jobs[i].job.link);
            m_ThreadPool.QueueJob(&amp;s_Jobs[i].job, i);
        }
        AtomicSetValue(m_bStarted, 1);
        return APFE_OK;
    }
    return APFE_SYS_ERROR;
}

void CNetworkMan::Stop()
{
    if (1 == atomic_comp_swap(&amp;m_bStarted, -1, 1)) {
        //TODO: stop all pollers
        int n = m_ThreadPool.GetWorkerCount();
        for (int i=0; i&lt;n; i++) {
            s_Jobs[i].poller.Close(); // &#21482;&#38656;&#35201;Close&#21363;&#21487;
        }
        //m_ThreadPool.Stop();
    }
}
</pre>


<p>
然后我们看看MyJob以及对应的Polling是如何实现的
</p>


<pre class="src src-C++">struct MyJob {
    Job job;
    volatile int count;
    CEPoller poller;
};
static MyJob s_Jobs[MAX_NR_NETWORK_WORKERS];
static void
Polling(Job* pJob)
{
    MyJob* pMyJob = CONTAINING_RECORD(pJob, MyJob, job);
    pMyJob-&gt;poller.Run(); // &#30452;&#25509;&#35843;&#29992;poller.Run()&#21363;&#21487;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-8-3" class="outline-5">
<h5 id="sec-1-2-8-3"><span class="section-number-5">1.2.8.3</span> Associate &amp; Deassociate</h5>
<div class="outline-text-5" id="text-1-2-8-3">

<p>Associate和Deassociate逻辑非常简单，无非就是将NetContext和网络线程池里面的EPoller绑定起来，将NetContext里面的fd给epoll来管理。
</p>


<pre class="src src-C++">APF_ERROR CNetworkMan::Associate(NetContext* pCtx)
{
    APF_ERROR err = APFE_NOT_CREATED;
    ASSERT(pCtx-&gt;state &gt; SS_VOID);

    // Note: we have to be careful here, if the number of pollers is dynamic
    // &#36873;&#25321;&#19968;&#20010;&#20851;&#32852;fd&#27604;&#36739;&#23569;&#30340;Poller&#26469;&#32465;&#23450;
    int x1=AtomicGetValue(s_Jobs[0].count), m=0, n;
    for (int i=1; i&lt;m_ThreadPool.GetWorkerCount(); i++) {
        n = AtomicGetValue(s_Jobs[i].count);
        if (n &lt; x1) {
            x1 = n;
            m = i;
        }
    }
    //int m = atomic_add(&amp;n, 1) % m_ThreadPool.GetWorkerCount();
    pCtx-&gt;pPoller = &amp;s_Jobs[m].poller;
    atomic_add(&amp;s_Jobs[m].count, 1);

    // &#36873;&#25321;&#22909;&#36825;&#20010;Poller&#20043;&#21518;&#65292;&#28982;&#21518;&#35843;&#29992;Poller-&gt;Associate&#21644;&#36825;&#20010;NetContext&#36827;&#34892;&#20851;&#32852;
    m_NetContexts.push_back(pCtx);
    if (APFE_OK != (err=pCtx-&gt;pPoller-&gt;Associate(pCtx))) {
        m_NetContexts.remove(pCtx);
    }
    return err;
}

APF_ERROR CNetworkMan::Deassociate(NetContext* pCtx)
{
    APF_ERROR err;
    MyJob* pJob;

    if (NULL != pCtx-&gt;pPoller) {
        if (APFE_OK == (err=pCtx-&gt;pPoller-&gt;Deassociate(pCtx))) { // &#35299;&#38500;&#20851;&#32852;
            m_NetContexts.remove(pCtx);
            pJob = CONTAINING_RECORD(pCtx-&gt;pPoller, MyJob, poller);
            atomic_add(&amp;pJob-&gt;count, -1);
        }
        return err;
    }
    m_NetContexts.remove(pCtx);
    return APFE_OK;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-8-4" class="outline-5">
<h5 id="sec-1-2-8-4"><span class="section-number-5">1.2.8.4</span> Listen</h5>
<div class="outline-text-5" id="text-1-2-8-4">

<p>发起Listen操作
</p>


<pre class="src src-C++">void CNetworkMan::Listen(NetContext* pCtx, int backlog)
{
    pCtx-&gt;backlog = backlog;
    pCtx-&gt;pClient-&gt;AddRef(); // &#36825;&#37324;AddRef&#20102;
    pCtx-&gt;state = SS_LISTENING_0; // &#27880;&#24847;&#29366;&#24577;
    Associate(pCtx);
    // TODO: error with Associate
}
</pre>


</div>

</div>

<div id="outline-container-1-2-8-5" class="outline-5">
<h5 id="sec-1-2-8-5"><span class="section-number-5">1.2.8.5</span> Connect</h5>
<div class="outline-text-5" id="text-1-2-8-5">

<p>发起Connect操作，注意这里还填写了WriteReq,timeout以及nAction=AA_CONNECT.对于pReq的话应该是在connect之后发起的写操作。
</p>


<pre class="src src-C++">void CNetworkMan::Connect(NetContext* pCtx, uint32 ip, uint16 port,
                          void *pBuf, int count, uint32 timeout, NetRequest* pReq)
{
    ASSERT(NULL != pReq);

    pCtx-&gt;ip = ip;
    pCtx-&gt;port = port;

    pReq-&gt;async.nAction = AA_CONNECT;
    pReq-&gt;pHdl = NULL;
    pReq-&gt;buf = pBuf;
    pReq-&gt;request = count;
    pReq-&gt;xfered = 0;
    pCtx-&gt;pWriteReq = pReq;
    pCtx-&gt;nTimeout = timeout;

    pCtx-&gt;pClient-&gt;AddRef();
    pCtx-&gt;state = SS_CONNECTING_0;
    Associate(pCtx);
    // TODO: error with Associate
}
</pre>


</div>

</div>

<div id="outline-container-1-2-8-6" class="outline-5">
<h5 id="sec-1-2-8-6"><span class="section-number-5">1.2.8.6</span> Monitor</h5>
<div class="outline-text-5" id="text-1-2-8-6">

<p>发起Monitor操作。所谓Monitor操作的话是指创建Socket成功之后的操作。代码这里的意图是创建服务端的Socket成功之后准备监听的状态。
</p>


<pre class="src src-C++">void CNetworkMan::Monitor(NetContext* pCtx)
{
    pCtx-&gt;pClient-&gt;AddRef();
    pCtx-&gt;state = SS_CONNECTED_0;
    Associate(pCtx);
    // TODO: error with Associate
}
</pre>


</div>

</div>

<div id="outline-container-1-2-8-7" class="outline-5">
<h5 id="sec-1-2-8-7"><span class="section-number-5">1.2.8.7</span> Delay</h5>
<div class="outline-text-5" id="text-1-2-8-7">

<p>发起一个读超时的操作
</p>


<pre class="src src-C++">bool CNetworkMan::Delay(NetContext* pCtx, uint32 nMilliseconds)
{
    bool bRet = false;
    int bDelay = AtomicSetValue(pCtx-&gt;nDelayRead, 1); // &#19981;&#33021;&#22815;&#37325;&#22797;&#21457;&#36215;
    if (0 == bDelay) {
        pCtx-&gt;pClient-&gt;AddRef();
        pCtx-&gt;pPoller-&gt;Delay(pCtx, nMilliseconds);
        bRet = true;
    }
    return bRet;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-8-8" class="outline-5">
<h5 id="sec-1-2-8-8"><span class="section-number-5">1.2.8.8</span> Read &amp; Write</h5>
<div class="outline-text-5" id="text-1-2-8-8">

<p>Read/Write过程非常简单，就是将Request封装好之后交给EPoller来处理。所以这里可以知道大部分的事情都是在Poller里面完成的。
</p>


<pre class="src src-C++">void CNetworkMan::Read(NetContext* pCtx, NetRequest* pReq)
{
    pReq-&gt;xfered = 0;
    pCtx-&gt;pPoller-&gt;Read(pCtx, pReq);
}
void CNetworkMan::Write(NetContext* pCtx, NetRequest* pReq)
{
    pReq-&gt;xfered = 0;
    pCtx-&gt;pPoller-&gt;Write(pCtx, pReq);
}
</pre>


</div>

</div>

<div id="outline-container-1-2-8-9" class="outline-5">
<h5 id="sec-1-2-8-9"><span class="section-number-5">1.2.8.9</span> SocketState</h5>
<div class="outline-text-5" id="text-1-2-8-9">

<ul>
<li>SS_VOID = 0, // 初始状态
</li>
<li>SS_LISTENING_0,  // 发起listen操作
</li>
<li>SS_LISTENING, // 执行listen之后
</li>
<li>SS_CONNECTING_0, // 发起connect操作
</li>
<li>SS_CONNECTING, // 执行connect之后,下一步是SS_CONNECTED,但是下次发起write操作
</li>
<li>SS_CONNECTED_0, // 启动monitor操作,下一步是SS_CONNECTED,但是下次发起read操作
</li>
<li>SS_CONNECTED, // 连接建立成功
</li>
<li>SS_ERROR, // socket错误
</li>
<li>SS_SHUTDOWN, // 对端已经关闭
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-1-2-9" class="outline-4">
<h4 id="sec-1-2-9"><span class="section-number-4">1.2.9</span> EPoller</h4>
<div class="outline-text-4" id="text-1-2-9">


</div>

<div id="outline-container-1-2-9-1" class="outline-5">
<h5 id="sec-1-2-9-1"><span class="section-number-5">1.2.9.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-2-9-1">

<p>对于EPoller来说的话里面每个接口似乎都很重要，所以有必要对每一个接口都进行分析。首先看看EPoller的完整接口
</p>


<pre class="src src-C+">class CEPoller
{
    int m_fd; // epoll fd
    uint64 m_nRead, m_nWrite; // &#35835;&#20889;&#23383;&#33410;&#25968;&#32479;&#35745;
    typedef TMultiMap&lt;uint64, NetContext&gt; DelayedList;
    DelayedList m_DelayedList; // &#23450;&#26102;&#21015;&#34920;
    CSpinLock m_DListLock;  // &#23450;&#26102;&#21015;&#34920;&#38145;

    bool StartWrite(NetContext* pCtx, bool bForce);
    bool StartRead(NetContext* pCtx, bool bUser);
    void DoWithDelayed();
    bool DoConnect(NetContext* pCtx);

  public:
    CEPoller() { m_fd = 0; m_nRead = m_nWrite = 0; }
    ~CEPoller() { Close(); }

    APF_ERROR Create(int size);
    void Close();

    APF_ERROR Associate(NetContext* pCtx);
    APF_ERROR Deassociate(NetContext* pCtx);
    APF_ERROR Run();

    bool CancelDelay(NetContext* pCtx);
    void Delay(NetContext* pCtx, uint32 nMilliseconds);
    void Read(NetContext* pCtx, NetRequest* pReq);
    void Write(NetContext* pCtx, NetRequest* pReq);
};
</pre>


</div>

</div>

<div id="outline-container-1-2-9-2" class="outline-5">
<h5 id="sec-1-2-9-2"><span class="section-number-5">1.2.9.2</span> Create &amp; Close</h5>
<div class="outline-text-5" id="text-1-2-9-2">

<p>Create和Close无非就是创建epoll fd
</p>


<pre class="src src-C++">APF_ERROR CEPoller::Create(int size)
{
    m_fd = sys_epoll_create(size);
    if (0 &lt; m_fd)
        return APFE_OK;
    PERROR(<span class="org-string">"epoll_create"</span>);
    return GetLastError();
}

void CEPoller::Close()
{
    // TODO::: cancel epoll_waiting...
    if (m_fd) {
        close(m_fd);
        m_fd = 0;
    }
}
</pre>


</div>

</div>

<div id="outline-container-1-2-9-3" class="outline-5">
<h5 id="sec-1-2-9-3"><span class="section-number-5">1.2.9.3</span> Associate &amp; Deassociate</h5>
<div class="outline-text-5" id="text-1-2-9-3">

<p>将NetContext的fd放入epoll中进行关联.
</p>


<pre class="src src-C++">APF_ERROR CEPoller::Associate(NetContext* pCtx)
{
    struct epoll_event ev;
    ASSERT(pCtx-&gt;state &gt; SS_VOID);

    SetNonBlock(pCtx-&gt;s); // &#39318;&#20808;&#35774;&#32622;&#25104;&#20026;&#38750;&#38459;&#22622;&#27169;&#24335;
    ev.events = EPOLLIN | EPOLLOUT | EPOLLERR | EPOLLET;
    ev.data.ptr = pCtx;

    //TRACE0(<span class="org-string">"before CEPoller::Associate\n"</span>);
    pCtx-&gt;pClient-&gt;AddRef(); // &#27880;&#24847;&#36825;&#37324;AddRef
    TRACE1(<span class="org-string">"Associate %x -&gt; %s\n"</span>, pCtx-&gt;s, pCtx-&gt;pClient-&gt;GetName());
    if (0 == sys_epoll_ctl(m_fd, EPOLL_CTL_ADD, pCtx-&gt;s, &amp;ev)) { // &#21152;&#20837;&#21040;epoll&#37324;&#38754;
        return APFE_OK;
    }
    PERROR(<span class="org-string">"epoll_ctl in Associate"</span>);
    pCtx-&gt;pClient-&gt;Release();
    return GetLastError();
}

APF_ERROR CEPoller::Deassociate(NetContext* pCtx)
{
    if (pCtx-&gt;s != INVALID_SOCKET) {
        if (0 == sys_epoll_ctl(m_fd, EPOLL_CTL_DEL, pCtx-&gt;s, NULL)) { // &#20174;epoll&#21024;&#38500;
            TRACE1(<span class="org-string">"Deassociate %x\n"</span>, pCtx-&gt;s);
            pCtx-&gt;s = INVALID_SOCKET;
            return APFE_OK;
        }
        return GetLastError();
    }
    return APFE_ALREADY_FREED;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-9-4" class="outline-5">
<h5 id="sec-1-2-9-4"><span class="section-number-5">1.2.9.4</span> DoConnect</h5>
<div class="outline-text-5" id="text-1-2-9-4">

<p>DoConnect是真实地进行connect操作
</p>


<pre class="src src-C++">bool CEPoller::DoConnect(NetContext* pCtx)
{
    SOCKADDR_IN sa;
    ZeroMemory(&amp;sa, sizeof(SOCKADDR_IN));
    sa.sin_port = htons(pCtx-&gt;port);
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = pCtx-&gt;ip;

    AtomicSetValue(pCtx-&gt;state, SS_CONNECTING);
    pCtx-&gt;tTimeoutCycle = 0;

    int err = connect(pCtx-&gt;s, (LPSOCKADDR)&amp;sa, sizeof(sa));
    //TRACE0(<span class="org-string">"connect = %d, %d, %s\n"</span>, err, errno, strerror(errno));
    if (EINPROGRESS == errno) {
        if (INFINITE != pCtx-&gt;nTimeout) { // &#22914;&#26524;&#38656;&#35201;&#35774;&#32622;&#36229;&#26102;&#30340;&#35805;
            Delay(pCtx, pCtx-&gt;nTimeout); // &#37027;&#20040;&#20250;&#21457;&#36215;&#19968;&#20010;&#36229;&#26102;&#25805;&#20316;
        }
        return true;
    }
    return 0 == err;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-9-5" class="outline-5">
<h5 id="sec-1-2-9-5"><span class="section-number-5">1.2.9.5</span> Delay &amp; CancalDelay</h5>
<div class="outline-text-5" id="text-1-2-9-5">

<p>Delay操作无非就是将超时事件到DelayedList里面，而CancalDelay是将对应的超时事件从DelayedList里面删除。
</p>


<pre class="src src-C++">void CEPoller::Delay(NetContext* pCtx, uint32 nMilliseconds)
{
    uint64 nCycle = rdtsc();
    nCycle += (GetCpuFreq() * nMilliseconds) / 1000;

    m_DListLock.Lock();
    m_DelayedList.insert(nCycle, pCtx);
    m_DListLock.Unlock();

    pCtx-&gt;tTimeoutCycle = nCycle; // &#36716;&#25442;&#25104;&#20026;&#32477;&#23545;&#36229;&#26102;&#26102;&#38388;&#65292;&#21333;&#20301;&#26159;cycle.
}

bool CEPoller::CancelDelay(NetContext* pCtx)
{
    bool bRet = false;
    if (0 != pCtx-&gt;tTimeoutCycle) {
        m_DListLock.Lock();
        bRet = m_DelayedList.remove(pCtx-&gt;tTimeoutCycle, pCtx);
        m_DListLock.Unlock();
    }
    return bRet;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-9-6" class="outline-5">
<h5 id="sec-1-2-9-6"><span class="section-number-5">1.2.9.6</span> DoWithDelayed &amp; DoWithError</h5>
<div class="outline-text-5" id="text-1-2-9-6">

<p>TODO(zhangyan04):这两个部分都非常杂并且细节很多，没有完全看懂。另外一个疑问就是对于Delay这种超时事件的话为什么不放在CPU的超时时间里面去完成。这样似乎会更加优雅。
而现在的情况就是NetworkMan里面管理了一个定时器，而CPU线程也有一个定时器，而从代码编写者的demo来没有使用过networkman定时器。
</p>
</div>

</div>

<div id="outline-container-1-2-9-7" class="outline-5">
<h5 id="sec-1-2-9-7"><span class="section-number-5">1.2.9.7</span> Read &amp; Write</h5>
<div class="outline-text-5" id="text-1-2-9-7">

<p>发起Read/Write最后都是调用StartRead/StartWrite
</p>


<pre class="src src-C++">void CEPoller::Read(NetContext* pCtx, NetRequest* pReq)
{
    pReq-&gt;async.nAction = AA_READ; // &#21457;&#36215;&#30340;Action&#26159;AA_READ
    pCtx-&gt;pClient-&gt;AddRef();
    pCtx-&gt;qRead.push_back(pReq); // &#25918;&#20837;read request queue.
    StartRead(pCtx, true);
}

void CEPoller::Write(NetContext* pCtx, NetRequest* pReq)
{
    pReq-&gt;async.nAction = AA_WRITE; // &#21457;&#36215;&#30340;Action&#26159;AA_WRITE
    pCtx-&gt;pClient-&gt;AddRef();
    pCtx-&gt;qWrite.push_back(pReq); // &#25918;&#20837;write request queue.
    StartWrite(pCtx, true);
}
</pre>


<p>
首先我们看看StartRead这个过程。这里所谓的StartRead不过就是尝试阅读访问一下Context看看是否可以读出数据。调用的时机一个是刚发起Read一个是EPoller::Run里面。
</p>


<pre class="src src-C++">bool CEPoller::StartRead(NetContext* pCtx, bool bUser)
{
    NetRequest* pReq;
    int t, n;

    while (0 == (t=pCtx-&gt;tRead.Add())) { // TODO(zhangyan04):&#36825;&#20010;&#22320;&#26041;&#23436;&#20840;&#27809;&#26377;&#30475;&#25026;
        if (SS_CONNECTED != AtomicGetValue(pCtx-&gt;state)) {
            TRACE1(<span class="org-string">"Not read due to state=%s\n"</span>, State2Str(pCtx-&gt;state));
            if (1 == pCtx-&gt;tRead.Set(0)) {
                return false;
            }
            continue;
        }
        if (NULL == pCtx-&gt;pReadReq) { // &#24471;&#21040;&#31532;&#19968;&#20010;ReadRequest.
            pCtx-&gt;pReadReq = pCtx-&gt;qRead.pop_front();
        }
        while (pCtx-&gt;pReadReq) {
            pReq = pCtx-&gt;pReadReq;
            ASSERT(pReq-&gt;len &gt; pReq-&gt;xfered);
            if (0 == (pCtx-&gt;flag &amp; SF_UDP)) { // &#22914;&#26524;&#26159;TCP&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;&#20351;&#29992;recv&#35835;&#21462;
                n = recv(pCtx-&gt;s, (char*)pReq-&gt;buf+pReq-&gt;xfered, pReq-&gt;len-pReq-&gt;xfered, 0);
                if (AtomicGetValue(g_nQuickAckMode)) {
                    SetQuickAck(pCtx-&gt;s);
                }
            }
            else {
                SOCKADDR_IN sa;
                socklen_t len = sizeof(sa);
                n = recvfrom(pCtx-&gt;s, (char*)pReq-&gt;buf+pReq-&gt;xfered, pReq-&gt;len-pReq-&gt;xfered, 0, (LPSOCKADDR)&amp;sa, &amp;len);
                pReq-&gt;port = ntohs(sa.sin_port);
                pReq-&gt;ip = sa.sin_addr.s_addr;
            }
            //TRACE5(<span class="org-string">"recv(%x, %p, %d): %d, %d(%s)\n"</span>, pCtx-&gt;s, (char*)pReq-&gt;buf+pReq-&gt;xfered,
            //      pReq-&gt;len-pReq-&gt;xfered, n, errno, strerror(errno));
            if (0&gt;n &amp;&amp; EAGAIN==errno) {
                pCtx-&gt;tRead.Set(0);
                return true;
            }
            else if (0 &lt; n) {
                m_nRead += n;
                pReq-&gt;xfered += n;
                if (pReq-&gt;xfered &gt;= pReq-&gt;request) { // &#22914;&#26524;xfered&#36229;&#36807;request&#30340;&#35805;&#65292;&#37027;&#20040;&#24819;&#19978;&#36827;&#34892;&#36890;&#30693;
                    // &#36825;&#37324;&#38656;&#35201;&#27880;&#24847;&#30340;&#23601;&#26159;&#65292;&#25152;&#35859;&#30340;xfered&#21487;&#33021;&#20250;&#36229;&#36807;request,&#21482;&#35201;buffer&#30340;&#31354;&#38388;&#23481;&#35768;
                    pCtx-&gt;pReadReq = NULL;
                    NotifyClient(0, pCtx, pReq);
                    pCtx-&gt;pReadReq = pCtx-&gt;qRead.pop_front();
                }
                g_pExecMan-&gt;RunTimer(); // &#24182;&#19988;&#35843;&#29992;RunTimer&#26469;&#26816;&#26597;&#36229;&#26102;&#24773;&#20917;
            }
            else {
                TRACE3(<span class="org-string">"Error in recv(%x, %d): %d, %d(%s)\n"</span>, pCtx-&gt;s, pReq-&gt;len-pReq-&gt;xfered,
                       n, errno, strerror(errno));
                AtomicSetValueIf(pCtx-&gt;state, SS_SHUTDOWN, SS_CONNECTED);
                shutdown(pCtx-&gt;s, SHUT_RDWR);
                pCtx-&gt;tRead.Set(0);
                return false;
            }
        }
        if (1 == (t=pCtx-&gt;tRead.Set(0))) {
            return SS_CONNECTED == AtomicGetValue(pCtx-&gt;state); // app may have called shutdown...
        }
    }
    if (0 &lt; t)
        return true;
    ASSERT(bUser);
    /* the last one in pCtx-&gt;qRead should be what we just inserted, unless
     * 1. there is concurrent read in other threads; or
     * 2. it has been notified in the failure handler of CSocketV.
     */
    pReq = pCtx-&gt;qRead.pop_back();
    if (pReq) { // TODO(zhangyan04):???
        NotifyClient(APFE_AFTER_BROKEN, pCtx, pReq);
    }
    return false;
}
</pre>


<p>
StartWrite这个过程也是非常相似的，不过为了方便起见的话每个Write操作都是使用BufHandle来管理的
</p>


<pre class="src src-C++">bool CEPoller::StartWrite(NetContext* pCtx, bool bUser)
{
    BufHandle* pHdl;
    int t, n;

    while (0 == (t=pCtx-&gt;tWrite.Add())) { // TODO(zhangyan04):&#23436;&#20840;&#27809;&#26377;&#30475;&#25026;
        if (SS_CONNECTED != AtomicGetValue(pCtx-&gt;state)) {
            TRACE1(<span class="org-string">"Not write due to state=%s\n"</span>, State2Str(pCtx-&gt;state));
            /*if (SS_ERROR == pCtx-&gt;state) {
                NetRequest* pReq;
                if (NULL != pCtx-&gt;pWriteReq) {
                    pReq = pCtx-&gt;pWriteReq;
                    pCtx-&gt;pWriteReq = NULL;
                    NotifyClient(APFE_NET_ERROR, pCtx, pReq);
                }
                for (pReq=pCtx-&gt;qWrite.pop_front(); pReq; pReq=pCtx-&gt;qWrite.pop_front()) {
                    NotifyClient(APFE_NET_ERROR, pCtx, pReq);
                }
            }*/
            if (1 == pCtx-&gt;tWrite.Set(0)) {
                return false;
            }
            continue;
        }
        n = 0;
        while (NULL != (pHdl=NotifyAndNextWrite(pCtx, n))) { // &#27599;&#27425;&#21462;&#20986;&#19968;&#20010;&#21512;&#36866;&#30340;BufHandle&#20986;&#26469;&#29992;&#20110;&#20889;,&#22914;&#26524;&#24050;&#32463;&#20889;&#23436;&#25104;&#30340;&#35805;&#20250;&#22312;&#37324;&#38754;&#36827;&#34892;&#36890;&#30693;
            ASSERT(0 != pHdl-&gt;nDataLen);
            if (0 == (pCtx-&gt;flag &amp; SF_UDP)) { // &#22914;&#26524;&#26159;tcp&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;send
                n = send(pCtx-&gt;s, pHdl-&gt;pBuf, pHdl-&gt;nDataLen, 0);
            }
            else {
                SOCKADDR_IN sa;
                ZeroMemory(&amp;sa, sizeof(SOCKADDR_IN));
                sa.sin_port = htons(pCtx-&gt;pWriteReq-&gt;port);
                sa.sin_family = AF_INET;
                sa.sin_addr.s_addr = pCtx-&gt;pWriteReq-&gt;ip;
                n = sendto(pCtx-&gt;s, pHdl-&gt;pBuf, pHdl-&gt;nDataLen, 0, (LPSOCKADDR)&amp;sa, sizeof(sa));
            }
            //TRACE5(<span class="org-string">"send(%x, %d): %d, %d(%s)\n"</span>, pCtx-&gt;s, pHdl-&gt;nDataLen, n, errno, strerror(errno));
            if (0 &lt; n) {
                pHdl-&gt;nDataLen -= n;
                ASSERT(pHdl-&gt;nDataLen &gt;= 0);
                ASSERT(NULL != pCtx-&gt;pWriteReq);
                pCtx-&gt;pWriteReq-&gt;xfered += n;
                m_nWrite += n;
                g_pExecMan-&gt;RunTimer();
            }
            else if (EAGAIN == errno) {
                pCtx-&gt;tWrite.Set(0);
                return true;
            }
            else {
                TRACE2(<span class="org-string">"Error in send(%x, %p, %d): %d, %d(%s), %s\n"</span>, pCtx-&gt;s, pHdl-&gt;pBuf,
                    pHdl-&gt;nDataLen, n, errno, strerror(errno), State2Str(pCtx-&gt;state));
                AtomicSetValueIf(pCtx-&gt;state, SS_SHUTDOWN, SS_CONNECTED);
                shutdown(pCtx-&gt;s, SHUT_RDWR);
                pCtx-&gt;tWrite.Set(0);
                return false;
            }
        }
        if (1 == (t=pCtx-&gt;tWrite.Set(0))) {
            return true;
        }
    }
    if (0 &lt; t)
        return true;
    ASSERT(bUser);
    /* the last one in pCtx-&gt;qWrite should be what we just inserted, unless
     * 1. there is concurrent write in other threads; or
     * 2. it has been notified in the failure handler of CSocketV.
     */
    NetRequest* pReq = pCtx-&gt;qWrite.pop_back();
    if (pReq) { // TODO(zhangyan04):???
        NotifyClient(APFE_AFTER_BROKEN, pCtx, pReq);
    }
    return false;
}
</pre>

<p>
这里面最主要的过程无非就是NotifyAndNextWrite.
</p>


<pre class="src src-C++">static BufHandle*
NotifyAndNextWrite(NetContext* pCtx, int nWritten)
{
    BufHandle* pHdl = &amp;pCtx-&gt;wHdl;
    NetRequest* pReq;

    if (0 == pHdl-&gt;nDataLen) { // &#22914;&#26524;&#24403;&#21069;&#30340;DataLen==0&#30340;&#35805;&#37027;&#20040;&#23601;&#38656;&#35201;&#25361;&#36873;&#19979;&#19968;&#20010;BufHandle&#20102;&#12290;
        if (NULL != (pHdl=pHdl-&gt;_next)) { // &#36941;&#21382;BufHandle&#38142;&#34920;&#30830;&#35748;&#20840;&#37096;&#20889;&#23436;
            pCtx-&gt;wHdl._next = pHdl-&gt;_next;
            pCtx-&gt;wHdl.pBuf = pHdl-&gt;pBuf;
            pCtx-&gt;wHdl.nDataLen = pHdl-&gt;nDataLen;
            ASSERT(pHdl-&gt;nDataLen != 0);
            return &amp;pCtx-&gt;wHdl;
        }

        if (NULL != pCtx-&gt;pWriteReq) { // &#24403;&#21069;&#30340;Request&#24050;&#32463;&#20889;&#23436;&#65292;&#37027;&#20040;&#38656;&#35201;&#19968;&#27425;&#36890;&#30693;
            ASSERT(0 != nWritten);
            pReq = pCtx-&gt;pWriteReq;
            pCtx-&gt;pWriteReq = NULL;
            NotifyClient(0, pCtx, pReq);
        }
        while (NULL != (pCtx-&gt;pWriteReq=pCtx-&gt;qWrite.pop_front())) { // &#25361;&#36873;&#20986;&#19979;&#19968;&#20010;Request.
            pHdl = &amp;pCtx-&gt;pWriteReq-&gt;hdl;
            while (pHdl &amp;&amp; 0==pHdl-&gt;nDataLen) {
                pHdl = pHdl-&gt;_next;
            }
            if (pHdl) {
                pCtx-&gt;wHdl._next = pHdl-&gt;_next;
                pCtx-&gt;wHdl.pBuf = pHdl-&gt;pBuf;
                pCtx-&gt;wHdl.nDataLen = pHdl-&gt;nDataLen;
                return &amp;pCtx-&gt;wHdl;
            }
            pReq = pCtx-&gt;pWriteReq;
            pCtx-&gt;pWriteReq = NULL;
            NotifyClient(0, pCtx, pReq); // &#22914;&#26524;&#25152;&#26377;&#30340;BufHandle&#20026;NULL&#30340;&#35805;&#65292;&#37027;&#20040;&#20063;&#30452;&#25509;&#36890;&#30693;&#20889;&#23436;
        }
        return NULL;
    }
    pHdl-&gt;pBuf += nWritten; // &#22914;&#26524;&#24403;&#21069;BufHandle&#27809;&#26377;&#25630;&#23450;&#30340;&#35805;&#65292;&#37027;&#20040;&#20462;&#25913;&#19968;&#19979;&#19979;&#19968;&#27425;&#20889;&#20559;&#31227;.
    return pHdl;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-9-8" class="outline-5">
<h5 id="sec-1-2-9-8"><span class="section-number-5">1.2.9.8</span> NofityClient</h5>
<div class="outline-text-5" id="text-1-2-9-8">

<p>当EPoller发现内部需要进行回调的话，那么就会通过NofityClient来通知客户进行回调。
</p>


<pre class="src src-C++">static void
NotifyClient(int nErrCode, NetContext* pCtx, NetRequest* pReq)
{
    CAsyncClient* pClient = pCtx-&gt;pClient;

    pReq-&gt;async.nErrCode = nErrCode;
    pReq-&gt;async.pClient = pClient;
    //int nAction = pReq-&gt;async.nAction;

    TRACE5(<span class="org-string">"Notify client (%p,%d) %d, %d, %p, %p\n"</span>, pClient, pClient-&gt;GetRef(), pReq-&gt;async.nAction, nErrCode, pCtx, pReq);
    if (0 != (pCtx-&gt;flag &amp; SF_DIRECT_CALLBACK)) { // &#22914;&#26524;flag&#37324;&#38754;&#26377;SF_DIRECT_CALLBACK,&#37027;&#20040;&#22312;&#26412;&#32447;&#31243;&#25191;&#34892;
        pClient-&gt;OnCompletion((AsyncContext*)pReq);
        pClient-&gt;Release();
    }
    else { // &#21542;&#21017;&#21152;&#20837;CPU&#32447;&#31243;&#25191;&#34892;
        g_pExecMan-&gt;QueueExec((AsyncContext*)pReq, true);
    }
    //TRACE0(<span class="org-string">"After EPoll::NotifyClient: %d\n"</span>, nAction);
}
</pre>

<p>
这是NotifyClient的一个版本，另外一个版本的原型是这样的
</p>


<pre class="src src-C++">static void NotifyClient(int nErrCode, int nAction, NetContext* pCtx);
</pre>

<p>
可以看到这个地方没有和任何的NetRequest进行关联，所以在内部实现的话会直接new一个出来，用户在处理这个逻辑时候需要记得释放。
</p>
</div>

</div>

<div id="outline-container-1-2-9-9" class="outline-5">
<h5 id="sec-1-2-9-9"><span class="section-number-5">1.2.9.9</span> Run</h5>
<div class="outline-text-5" id="text-1-2-9-9">

<p>过程比较冗长，而且里面很多细节依然并不是非常清楚，但是不妨碍大体的理解
</p>


<pre class="src src-C++">APF_ERROR CEPoller::Run()
{
    NetContext* pCtx;
    NetRequest *pReq;
#define MAX_EPOLL_EVENT     64
    struct epoll_event events[MAX_EPOLL_EVENT];
    int nfds;
    bool bRead, bWrite, bErr;

    while (1) {
        TRACE7(<span class="org-string">"epoll_wait start\n"</span>);
        nfds = sys_epoll_wait(m_fd, events, MAX_EPOLL_EVENT, g_nTickPrecision); // &#36827;&#34892;epoll_wait
        TRACE7(<span class="org-string">"epoll_wait return: nfds=%d\n"</span>, nfds);
        if (nfds &gt;= 0) {
            for (int i=0; i&lt;nfds; i++) {
                pCtx = (NetContext*)events[i].data.ptr;
                ASSERT(pCtx &amp;&amp; pCtx-&gt;pClient);
                if (0 == pCtx-&gt;nEnabled) { // &#22914;&#26524;&#19981;&#21487;&#29992;&#30340;&#35805;&#37027;&#20040;&#24573;&#30053;
                    continue;
                }
                bRead = (events[i].events &amp; EPOLLIN) ? true : false;
                bWrite = (events[i].events &amp; EPOLLOUT) ? true : false;
                bErr = (events[i].events &amp; EPOLLERR) ? true : false;

#ifdef  _DEBUG
                if (0 != bErr) {
                    TRACE4(<span class="org-string">"EPOLLERR: %x(%p), state=%s\n"</span>, pCtx-&gt;s, pCtx, State2Str(pCtx-&gt;state));
                }
                if (bRead) {
                    TRACE7(<span class="org-string">"EPOLLIN: %x(%p), state=%s\n"</span>, pCtx-&gt;s, pCtx, State2Str(pCtx-&gt;state));
                }
                if (bWrite) {
                    TRACE7(<span class="org-string">"EPOLLOUT: %x(%p), state=%s\n"</span>, pCtx-&gt;s, pCtx, State2Str(pCtx-&gt;state));
                }
#endif
                switch (AtomicGetValue(pCtx-&gt;state)) {
                case SS_CONNECTED_0:            // support for Monitor
                    AtomicSetValue(pCtx-&gt;state, SS_CONNECTED);
                    NotifyClient(APFE_NOTIFY, AA_READ, pCtx);
                    // no break
                case SS_CONNECTED: // &#22914;&#26524;&#24050;&#32463;&#36830;&#25509;&#19978;&#30340;&#35805;
                    if (bRead) {
                        while (pCtx-&gt;tRead.Get() &gt; 0) {
                            thread_yield();
                        }
                        if (!StartRead(pCtx, false)) { // &#21457;&#36215;Read&#25805;&#20316;
                            DoWithError(pCtx);
                            break;
                        }
                    }

                    if (!bErr) {
                        if (bWrite) {
                            while (pCtx-&gt;tWrite.Get() &gt; 0) {
                                thread_yield();
                            }
                            if (!StartWrite(pCtx, false)) { // &#21457;&#36215;Write&#25805;&#20316;
                                DoWithError(pCtx);
                                break;
                            }
                        }
                    }
                    else {
                        int bytes = 0;
                        if (0 == (pCtx-&gt;flag &amp; SF_DONT_EXHAUST)) {
                            ioctl(pCtx-&gt;s, FIONREAD, &amp;bytes);
                        }
                        if (0 == bytes) { // &#22914;&#26524;&#22312;&#32531;&#23384;&#37324;&#38754;&#27809;&#26377;&#25968;&#25454;&#30340;&#35805;&#65292;&#21542;&#21017;&#20250;&#20808;&#35302;&#21457;READ&#20107;&#20214;
                            AtomicSetValueIf(pCtx-&gt;state, SS_SHUTDOWN, SS_CONNECTED); // &#37027;&#20040;&#23558;&#29366;&#24577;&#32622;&#20026;Shutdown
                            DoWithError(pCtx); // &#20132;&#32473;&#38169;&#35823;&#22788;&#29702;
                        }
                    }
                    break;

                case SS_CONNECTING_0:
                    if (DoConnect(pCtx)) // &#21457;&#36215;connect
                        break;
                    bErr = true;

                case SS_CONNECTING:
                    CancelDelay(pCtx); // &#22914;&#26524;&#26159;&#27491;&#22312;&#36830;&#25509;&#30340;&#35805;&#37027;&#20040;&#21462;&#28040;ReConnect&#36229;&#26102;&#26102;&#38388;,Connect&#19978;&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#31435;&#21051;&#35302;&#21457;&#20889;&#20107;&#20214;
                    if (!bErr &amp;&amp; bWrite) {
                        pReq = pCtx-&gt;pWriteReq;
                        pCtx-&gt;pWriteReq = NULL;
                        ASSERT(pReq != pCtx-&gt;qWrite.get_front());

                        if (0==pReq-&gt;request &amp;&amp; NULL==pReq-&gt;pHdl) {
                            AtomicSetValue(pCtx-&gt;state, SS_CONNECTED);
                            NotifyClient(0, pCtx, pReq); // &#22914;&#26524;&#27809;&#26377;&#20889;&#35831;&#27714;&#30340;&#35805;&#37027;&#20040;&#35302;&#21457;&#22238;&#35843;
                        }
                        else {
                            pCtx-&gt;qWrite.push_front(pReq);
                            AtomicSetValue(pCtx-&gt;state, SS_CONNECTED);
                        }
                        if (!StartWrite(pCtx, false)) { // &#22914;&#26524;&#26377;&#20889;&#35831;&#27714;&#37027;&#20040;&#31435;&#21051;&#36827;&#34892;Write
                            DoWithError(pCtx);
                        }
                    }
                    else if (bErr) {
                        DoWithError(pCtx);
                    }
                    break;

                case SS_LISTENING_0:
                    DoListen(pCtx);
                    break;

                case SS_LISTENING:
                    // TODO: how to deal with listen failure?
                    if (!bErr &amp;&amp; bRead) {
                        pCtx-&gt;pClient-&gt;AddRef();
                        NotifyClient(APFE_OK, AA_LISTEN, pCtx); // AA_LISTEN&#23436;&#27605;&#65292;&#37027;&#20040;&#30456;&#24403;&#20110;&#19979;&#19968;&#27493;&#25105;&#20204;&#38656;&#35201;&#36827;&#34892;accept.
                    }
                    break;

                case SS_SHUTDOWN:
                    DoWithError(pCtx);
                    break;

                default:
                    break;
                }
            }

            DoWithDelayed();
            g_pExecMan-&gt;RunTimer();
        }
        else if (EINTR != GetLastError()) {
            if (IsKylinRunning())
                PERROR(<span class="org-string">"Error in epoll_wait"</span>);
            return GetLastError();
        }
    }
    return APFE_OK;
}
</pre>

<p>
可以说看下来的话很多细节都是头昏脑胀的，以及各种情况返回什么样的错误码。估计只有写代码的人才知道里面为什么这么做，里面到底存在什么陷阱。
但是所幸的是写代码的人为我们提供了一个简单的接口可以使用，而且里面设置了很多默认的处理。大部分情况下面我们只需要使用默认处理即可，这个默认类就是Socket.
</p>
</div>
</div>

</div>

<div id="outline-container-1-2-10" class="outline-4">
<h4 id="sec-1-2-10"><span class="section-number-4">1.2.10</span> Socket</h4>
<div class="outline-text-4" id="text-1-2-10">


</div>

<div id="outline-container-1-2-10-1" class="outline-5">
<h5 id="sec-1-2-10-1"><span class="section-number-5">1.2.10.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-2-10-1">

<p>Socket包含了如何配合使用NetworkMan以及EPoller两个部分，并且里面提供了很多默认的封装。对于我们编写程序的话大部分时候都使用这个类即可。还是首先看看接口
</p>


<pre class="src src-C++">// socket&#31867;&#22411;
enum SockType {
    ST_NONE = 0,
    ST_CREATED,
    ST_LISTEN,
    ST_CONNECTED,
    ST_ACCEPTED,
    ST_ERROR
};

class CSocketV : public CAsyncClient
{
  protected:
    SOCKET m_s; // socket&#21477;&#26564;
    uint16 m_port; // &#24037;&#20316;&#22312;&#20160;&#20040;&#31471;&#21475;&#19978;&#65292;&#22914;&#26524;&#26159;connection&#30340;&#35805;&#34920;&#31034;&#23458;&#25143;&#31471;&#30340;&#31471;&#21475;
    NetContext m_Ctx; // context
    NetRequest m_Req; // request
    volatile int m_type; // socket&#31867;&#22411;
    AsyncContext* m_pConnCtx; // &#27809;&#26377;&#20351;&#29992;

    CSocketV() {
        m_s = INVALID_SOCKET;
        m_port = 0;
        m_type = ST_NONE;
        m_pConnCtx = NULL;
        InitAsyncContext(&amp;m_Req.async);
    }
    virtual ~CSocketV() {
        Close();
    }

    virtual void OnCompletion(AsyncContext* pContext);

    // false means the connection is to be deleted
    virtual bool OnConnected(APF_ERROR nErrCode) { return 0==nErrCode; }
    virtual void OnListened(SOCKET s, SOCKADDR_IN* pSockAddrIn) { closesocket(s); }

    virtual void OnWritten(APF_ERROR nErrCode, NetRequest* pReq) {}
    virtual void OnRead(APF_ERROR nErrCode, NetRequest* pReq) {}

    virtual void OnBroken(APF_ERROR nErrCode) = 0;
    bool Close();

  public:
    virtual int Release() {
        int n = CAsyncClient::Release();
        if (n == 0) {
            delete this;
        }
        return n;
    }
    APF_ERROR Create(bool bTCP, uint16 port=0, uint32 ip=0, uint32 flag=0); // Check SocketFlag in NetworkMan.h
    APF_ERROR Create(SOCKET s, uint16 port, uint32 flag=0);

    void Listen(int backlog=64);
    void Connect(uint32 ip, uint16 port, uint32 timeout=INFINITE/*in Milliseconds*/);
    void ConnectAndWrite(uint32 ip, uint16 port, void* pBuf, int count, uint32 timeout=INFINITE/*in Milliseconds*/);
    void ReConnect(uint32 nMilliseconds);
    bool Shutdown(bool bLingerOff=true);

    void Read(void* pBuf, int count, int request, NetRequest* pReq);
    void Read(void* pBuf, int count, NetRequest* pReq);
    void Write(void* pBuf, int count, NetRequest* pReq);
    void Write(BufHandle* pHdl, NetRequest* pReq);

#ifdef _UNITTEST
    NetContext* GetCtx() { return &amp;m_Ctx; }
#endif
};
</pre>


</div>

</div>

<div id="outline-container-1-2-10-2" class="outline-5">
<h5 id="sec-1-2-10-2"><span class="section-number-5">1.2.10.2</span> Create</h5>
<div class="outline-text-5" id="text-1-2-10-2">

<p>对于create的话我们看稍微复杂的一个实现，就是头参数是bTCP的原型实现。注意这里ip=0,port=0的话那么这样对于client来说的话就会随机选择一个端口。
</p>


<pre class="src src-C++">APF_ERROR CSocketV::Create(bool bTCP, uint16 port, uint32 ip, uint32 flag)
{
    APF_ERROR err;
    ASSERT(!IsCreated());
    int retry = 0;
    SOCKADDR_IN sa;

retry1:
    m_s = WSASocket(AF_INET, bTCP ? SOCK_STREAM : SOCK_DGRAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED); // &#26500;&#36896;socket.
    if (INVALID_SOCKET != m_s) {
        atomic_add(&amp;s_nSockets, 1);
        SetReuseAddr(m_s); // &#24182;&#19988;&#35774;&#32622;reuseadd.
    }
    else {
        err = WSAGetLastError();
        TRACE0(<span class="org-string">"WSASocket() error: %d(%s)\n"</span>, err, strerror(err));
        if (retry++ &lt; 10) { // &#21019;&#24314;socket&#21487;&#33021;&#20250;&#22240;&#20026;&#21477;&#26564;&#19978;&#32447;&#32780;&#21019;&#24314;&#22833;&#36133;&#65292;&#36825;&#37324;&#20250;&#36827;&#34892;&#37325;&#35797;&#12290;
            // it should be 24: too many open files, we may need to sleep and retry
            Sleep(500);
            TRACE0(<span class="org-string">"Retry %d\n"</span>, retry);
            goto retry1;
        }
        else {
            TRACE0(<span class="org-string">"Total sockets: %d\n"</span>, AtomicGetValue(s_nSockets));
            return err;
        }
    }

    retry = 0;
retry2:
    ZeroMemory(&amp;sa, sizeof(SOCKADDR_IN));
    sa.sin_port = htons(port);
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = ip;

    UNLIKELY_IF (SOCKET_ERROR == bind(m_s, (LPSOCKADDR)&amp;sa, sizeof(sa))) { // &#28982;&#21518;&#36827;&#34892;&#32465;&#23450;&#65292;&#20854;&#23454;&#23545;&#20110;client&#21487;&#26377;&#21487;&#26080;&#20294;&#26159;&#27809;&#26377;&#20219;&#20309;&#24433;&#21709;
        err = WSAGetLastError();
        TRACE0(<span class="org-string">"Error in bind(%s, %d): %s\n"</span>, bTCP?<span class="org-string">"TCP"</span>:<span class="org-string">"UDP"</span>, port, strerror(err));

        retry ++;
        if (retry&lt;3 || (0==port &amp;&amp; retry&lt;10)) { // TODO(zhangyan04):&#36825;&#37324;&#37325;&#35797;&#21407;&#22240;&#19981;&#22826;&#28165;&#26970;
            Sleep(500);
            TRACE0(<span class="org-string">"Retry %d\n"</span>, retry);
            goto retry2;
        }

        // fail to bind
        closesocket(m_s);
        m_s = INVALID_SOCKET;
        return err;
    }
    if (0 == port) { // &#22914;&#26524;&#20351;&#29992;0&#31471;&#21475;&#26469;&#21019;&#24314;&#30340;&#35805;&#37027;&#20040;&#21487;&#20197;&#36890;&#36807;getsockname&#26469;&#24471;&#21040;&#26368;&#32456;&#32465;&#23450;&#21040;&#30340;&#31471;&#21475;
        socklen_t namelen = sizeof(sa);
        getsockname(m_s, (LPSOCKADDR)&amp;sa, &amp;namelen);
        port = ntohs(sa.sin_port);
    }

    InitNetContext(&amp;m_Ctx, m_s, this, flag);
    m_Ctx.ip = ip;
    m_Ctx.port = port;

    SetName(<span class="org-string">"Socket(%x)"</span>, m_s);
    TRACE4(<span class="org-string">"%s %s created, port=%d\n"</span>, m_name, bTCP?<span class="org-string">"TCP"</span>:<span class="org-string">"UDP"</span>, port);
    m_port = port;
    AtomicSetValue(m_type, ST_CREATED); // &#36825;&#26159;&#25104;&#20026;ST_CRERATED&#31867;&#22411;
    if (!bTCP) {
        m_Ctx.flag |= SF_UDP;
        g_pNetworkMan-&gt;Monitor(&amp;m_Ctx);
    }
    return APFE_OK;
}
</pre>


<p>
后来我觉得这个Create原型我们也还是值得看看的，因为这个函数原型通常是在server进行accept之后触发的create
</p>


<pre class="src src-C++">APF_ERROR CSocketV::Create(SOCKET s, uint16 port, uint32 flag)
{
    ASSERT(!IsCreated());

    s_nSockets ++;
    m_s = s;
    m_port = port;
    InitNetContext(&amp;m_Ctx, m_s, this, flag);
    m_Ctx.port = port;

    AtomicSetValue(m_type, ST_CREATED);
    SetName(<span class="org-string">"Socket(%x)"</span>, m_s);
    g_pNetworkMan-&gt;Monitor(&amp;m_Ctx); // &#31435;&#21363;&#21551;&#21160;monitor.monitor&#29366;&#24577;&#22312;run&#37324;&#38754;&#30340;&#35805;&#23601;&#20250;&#36890;&#36807;(APFE_NOTIFY,AA_READ)&#26469;&#36890;&#30693;server&#24212;&#35813;&#21457;&#36215;&#35835;&#25805;&#20316;&#20102;.
    // Monitor&#26080;&#38750;&#23601;&#26159;&#36890;&#30693;&#26381;&#21153;&#22120;&#21018;&#36830;&#25509;&#19978;&#26469;&#30340;&#23458;&#25143;&#31471;&#21487;&#35835;&#20102;&#12290;
    return APFE_OK;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-10-3" class="outline-5">
<h5 id="sec-1-2-10-3"><span class="section-number-5">1.2.10.3</span> Close</h5>
<div class="outline-text-5" id="text-1-2-10-3">




<pre class="src src-C++">bool CSocketV::Close()
{
    if (INVALID_SOCKET != m_s) { // &#21487;&#20197;&#22810;&#27425;&#35843;&#29992;Close
        g_pNetworkMan-&gt;Deassociate(&amp;m_Ctx); // &#23558;&#36825;&#20010;NetContext&#20174;NetworkMan&#35299;&#38500;&#20851;&#32852;
        closesocket(m_s);
        m_s = INVALID_SOCKET;
        atomic_add(&amp;s_nSockets, -1);

        // &#36825;&#20010;&#22320;&#26041;&#26159;&#36825;&#20040;&#29468;&#27979;&#30340;&#65292;&#26222;&#36890;&#31867;&#22411;socket&#30340;&#35805;&#20165;&#20165;&#26159;&#20026;&#20102;&#21333;&#36830;&#25509;&#36890;&#20449;&#23384;&#22312;&#30340;
        // &#22914;&#26524;&#36827;&#34892;close&#30340;&#35805;&#23436;&#20840;&#21487;&#20197;&#30452;&#25509;&#20002;&#24323;&#65292;&#32780;&#23545;&#20110;listen&#26469;&#35828;&#30340;&#35805;&#65292;&#22914;&#26524;&#19968;&#26086;&#30452;&#25509;&#20851;&#38381;&#37027;&#20040;&#26381;&#21153;&#23601;&#19981;&#33021;&#22815;&#32500;&#25345;
        // &#19981;&#36807;&#35805;&#35828;&#22238;&#26469;&#20010;&#20154;&#24863;&#35273;&#36825;&#20010;&#22320;&#26041;&#36824;&#26159;&#25402;non-sense&#30340;
        if (ST_LISTEN == AtomicSetValue(m_type, ST_NONE)) {
            Release();
        }
        return true;
    }
    return false;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-10-4" class="outline-5">
<h5 id="sec-1-2-10-4"><span class="section-number-5">1.2.10.4</span> Shutdown</h5>
<div class="outline-text-5" id="text-1-2-10-4">




<pre class="src src-C++">bool CSocketV::Shutdown(bool bLingerOff)
{
    int state = AtomicSetValue(m_Ctx.state, SS_SHUTDOWN);
    if (INVALID_SOCKET != m_s) {
        TRACE2(<span class="org-string">"Shutdown socket(%x), LingerOff=%d\n"</span>, m_s, bLingerOff);
        if (bLingerOff) { // &#25105;&#20204;&#19981;care&#36825;&#20010;linger&#37096;&#20998;
            SetLingerOff(m_s);
        }
        shutdown(m_s, SHUT_RDWR);
        if (SS_CONNECTING_0==state &amp;&amp; !g_pNetworkMan-&gt;Delay(&amp;m_Ctx, 0)) { // &#36825;&#20010;&#22320;&#26041;&#36825;&#20040;&#22788;&#29702;&#21407;&#22240;
            // &#26159;&#22240;&#20026;&#22914;&#26524;&#25105;&#20204;&#24403;&#21069;&#26159;&#36825;&#26679;&#29366;&#24577;&#30340;&#35805;&#65292;&#24182;&#19988;&#24050;&#32463;&#21457;&#36215;&#20102;&#19968;&#20010;Delay&#20107;&#20214;&#30340;&#35805;
            // &#37027;&#20040;&#32943;&#23450;&#20250;&#34987;&#36890;&#30693;&#21040;&#28982;&#21518;&#35843;&#29992;NotifyClient&#65292;&#25152;&#20197;&#36825;&#25105;&#20204;&#38656;&#35201;&#39318;&#20808;AddRef.
            AddRef();
        }
        return true;
    }
    return false;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-10-5" class="outline-5">
<h5 id="sec-1-2-10-5"><span class="section-number-5">1.2.10.5</span> Listen</h5>
<div class="outline-text-5" id="text-1-2-10-5">




<pre class="src src-C++">void CSocketV::Listen(int backlog)
{
    ASSERT(IsCreated());

    AtomicSetValue(m_type, ST_LISTEN); // &#35774;&#32622;&#25104;&#20026;ST_LISTEN&#29366;&#24577;
    g_pNetworkMan-&gt;Listen(&amp;m_Ctx, backlog); // &#28982;&#21518;&#21457;&#36215;listen
}
</pre>


</div>

</div>

<div id="outline-container-1-2-10-6" class="outline-5">
<h5 id="sec-1-2-10-6"><span class="section-number-5">1.2.10.6</span> Connect</h5>
<div class="outline-text-5" id="text-1-2-10-6">

<p>Connect相关函数有Connect,ConnectAndWrite以及ReConnect,都非常简单通过NetworkMan发起操作
</p>


<pre class="src src-C++">void CSocketV::Connect(uint32 ip, uint16 port, uint32 timeout)
{
    //TRACE5(<span class="org-string">"Connecting(%x) %s:%d...\n"</span>, m_s, in_ntoa(ip), port);
    ASSERT(IsCreated());
    g_pNetworkMan-&gt;Connect(&amp;m_Ctx, ip, port, NULL, 0, timeout, &amp;m_Req);
}

void CSocketV::ConnectAndWrite(uint32 ip, uint16 port, void* pBuf, int count, uint32 timeout)
{
    //TRACE5(<span class="org-string">"Connecting(%x) %s:%d...\n"</span>, m_s, in_ntoa(ip), port);
    ASSERT(IsCreated());
    g_pNetworkMan-&gt;Connect(&amp;m_Ctx, ip, port, pBuf, count, timeout, &amp;m_Req);
}

void CSocketV::ReConnect(uint32 nMilliseconds)
{
    m_Ctx.pWriteReq = &amp;m_Req;
    m_Ctx.nDelayRead = 0;
    m_Ctx.tRead.Init();
    m_Ctx.tWrite.Init();
    m_Ctx.state = SS_CONNECTING_0;
    g_pNetworkMan-&gt;Delay(&amp;m_Ctx, nMilliseconds); // &#21482;&#26377;&#36825;&#31181;SS_CONNECTING_0&#29366;&#24577;&#25165;&#20250;&#21457;&#36215;Delay&#20107;&#20214;
}
</pre>


</div>

</div>

<div id="outline-container-1-2-10-7" class="outline-5">
<h5 id="sec-1-2-10-7"><span class="section-number-5">1.2.10.7</span> Read &amp; Write</h5>
<div class="outline-text-5" id="text-1-2-10-7">

<p>Read/Write函数也非常简单无非就是包装一些NetRequest然后交给NetworkMan来发起
</p>


<pre class="src src-C++">void CSocketV::Read(void* pBuf, int count, int request, NetRequest* pReq)
{
    g_pNetworkMan-&gt;Read(&amp;m_Ctx, pBuf, count, request, pReq);
}

void CSocketV::Write(void* pBuf, int count, NetRequest* pReq)
{
    g_pNetworkMan-&gt;Write(&amp;m_Ctx, pBuf, count, pReq);
}
</pre>


</div>

</div>

<div id="outline-container-1-2-10-8" class="outline-5">
<h5 id="sec-1-2-10-8"><span class="section-number-5">1.2.10.8</span> OnCompletion</h5>
<div class="outline-text-5" id="text-1-2-10-8">

<p>其实对于Socket部分最主要的内容还是在这里。上面那些函数无非是做一个Wrapper，而Socket本质上还是一个CAsyncClient要处理各种事件回调。
我们需要仔细看看OnCompletion的过程，因为大部分我们所需要扩展的就是这个部分了。但是如果仔细阅读这个部分的话，还是会发现有很多细节的东西的。
</p>


<pre class="src src-C++">void CSocketV::OnCompletion(AsyncContext* pContext)
{
    NetRequest* pReq = (NetRequest*)pContext;
    int nAction = pContext-&gt;nAction;
    switch (nAction) {
    case AA_READ: // &#22914;&#26524;&#25105;&#20204;&#21457;&#36215;&#30340;&#26159;READ&#30340;&#35805;&#65292;&#37027;&#20040;&#35302;&#21457;OnRead&#22238;&#35843;
        // &#21487;&#33021;&#23384;&#22312;&#30340;ErrCode&#21253;&#25324;
        // APFE_AFTER_BROKEN TODO(zhangyan04):how to handle
        // APFE_NET_ERROR TODO(zhangyan04):how to handle
        // APFE_NOTIFY &#38656;&#35201;&#25105;&#20204;&#33258;&#24049;&#37322;&#25918;pReq,&#22240;&#20026;&#36825;&#20010;&#26159;new&#20986;&#26469;&#30340;.&#36890;&#24120;&#25105;&#20204;&#26377;&#26032;&#30340;client&#36830;&#25509;&#19978;&#26469;&#24212;&#35813;&#21457;&#36215;&#35835;&#25805;&#20316;&#20102;
        // APFE_OK &#21457;&#36215;&#30340;&#35835;&#25805;&#20316;&#27809;&#26377;&#20219;&#20309;&#38169;&#35823;
        OnRead(pContext-&gt;nErrCode, pReq);
        break;

    case AA_WRITE: // &#22914;&#26524;&#25105;&#20204;&#21457;&#36215;&#30340;&#26159;WRITE&#25805;&#20316;&#30340;&#35805;&#65292;&#37027;&#20040;&#35302;&#21457;OnWrite&#22238;&#35843;
        // &#21487;&#33021;&#23384;&#22312;&#30340;ErrCode&#21253;&#25324;
        // APFE_AFTER_BROKEN TODO(zhangyan04):how to handle
        // APFE_NET_ERROR TODO(zhangyan04):how to handle
        // APFE_OK &#21457;&#36215;&#30340;&#20889;&#25805;&#20316;&#27809;&#26377;&#20219;&#20309;&#38169;&#35823;
        OnWritten(pContext-&gt;nErrCode, pReq);
        break;

    case AA_LISTEN: // &#22914;&#26524;&#25105;&#20204;&#21457;&#36215;&#30340;&#26159;LISTEN&#25805;&#20316;&#30340;&#35805;
        if (0 == pContext-&gt;nErrCode) { // listen&#35843;&#29992;&#27809;&#26377;&#20219;&#20309;&#38382;&#39064;
            while (1) {
                SOCKADDR_IN sa;
                socklen_t saLen = sizeof(sa);

                TRACE7(<span class="org-string">"To accept(%x)\n"</span>, m_s);
                SOCKET s = accept(m_s, (LPSOCKADDR)&amp;sa, &amp;saLen);
                if (-1 != s) {
                    TRACE1(<span class="org-string">"Accepted(%x) %s:%d = %x\n"</span>, m_s, in_ntoa(sa.sin_addr.s_addr), ntohs(sa.sin_port), s);
                    OnListened(s, &amp;sa); // &#23545;&#20110;&#27599;&#19968;&#20010;accept&#37117;&#35302;&#21457;OnListened&#22238;&#35843;
                }
                else {
                    TRACE7(<span class="org-string">"Error in accept(%x)\n"</span>, m_s);
                    break;
                }
            }
        }
        delete pReq;
        break;

    case AA_CONNECT: // &#22914;&#26524;&#25105;&#20204;&#21457;&#36215;&#30340;&#26159;CONNECT&#25805;&#20316;&#30340;&#35805;
        AtomicSetValue(m_type, ST_CONNECTED);
        TRACE1(<span class="org-string">"OnConnected(%x): %d, %p\n"</span>, m_s, pContext-&gt;nErrCode, pContext);
        if (0 == pContext-&gt;nErrCode) {
            OnConnected(0); // &#24182;&#19988;&#27809;&#26377;&#20219;&#20309;&#38169;&#35823;&#65292;&#37027;&#20040;&#35302;&#21457;OnConnected(0)
            break;
        }
        else if (OnConnected(pContext-&gt;nErrCode)) { // &#22914;&#26524;OnConnected(err)&#36820;&#22238;true&#30340;&#35805;&#37027;&#20040;&#24573;&#30053;
            break;
        }

        pContext-&gt;nErrCode = APFE_CONNECT_ERROR; // &#22914;&#26524;&#35748;&#20026;connect&#36825;&#26679;&#26159;&#19968;&#20010;&#38169;&#35823;&#30340;&#35805;&#65292;&#37027;&#20040;&#21518;&#38754;&#30340;&#38169;&#35823;&#37117;&#26159;APFE_CONNECT_ERROR
        Release(); // TODO(zhangyan04):&#36825;&#20010;&#22320;&#26041;&#20026;&#20160;&#20040;&#38656;&#35201;Release
        // &#21407;&#22240;&#26159;&#22240;&#20026;&#20316;&#32773;&#20551;&#35774;&#25105;&#20204;&#32534;&#20889;&#26041;&#24335;&#37117;&#26159;&#22312;&#21021;&#22987;&#21270;&#24320;&#22987;AddRef&#19968;&#19979;&#65292;&#28982;&#21518;&#23545;&#20110;OnBorken&#36825;&#31867;&#38169;&#35823;&#30340;&#35805;&#36890;&#24120;&#38656;&#35201;&#26512;&#26500;CAsyncClient,&#25152;&#20197;Release&#35753;&#25105;&#20204;&#21487;&#20197;&#38144;&#27585;
        // goes here

    case AA_BROKEN: // &#36830;&#25509;&#26029;&#24320;&#65292;&#21487;&#33021;&#26159;&#23458;&#25143;&#31471;&#30340;&#27491;&#24120;&#20851;&#38381;
        // &#20294;&#26159;&#38169;&#35823;&#30721;&#21487;&#33021;&#26377;&#19979;&#38754;&#36825;&#20123;
        // APFE_CONNECT_ERROR &#36830;&#25509;&#20986;&#29616;&#38169;&#35823;
        // APFE_TIMEDOUT &#36830;&#25509;&#20986;&#29616;&#36229;&#26102;
        // APFE_SYS_ERROR TODO(zhangyan04):???
        // APFE_NET_ERROR TODO(zhangyan04):???
        TRACE5(<span class="org-string">"CSocket::OnBroken(%x): %d\n"</span>, m_s, pContext-&gt;nErrCode);
        AtomicSetValue(m_type, ST_ERROR);
        ASSERT(NULL == m_Ctx.pReadReq);
        ASSERT(NULL == m_Ctx.pWriteReq);

        m_Ctx.tWrite.Set(LARGE_ENOUGH_NEGATIVE);
        m_Ctx.tRead.Set(LARGE_ENOUGH_NEGATIVE);
        // &#22914;&#26524;&#25552;&#20132;&#20102;&#36825;&#20123;&#35831;&#27714;&#30340;&#35805;&#65292;&#37027;&#20040;&#37117;&#20250;&#37325;&#26032;&#35302;&#21457;&#19968;&#27425;OnWritten/OnRead&#24182;&#19988;&#20197;&#23545;&#24212;&#30340;&#38169;&#35823;&#21495;&#36890;&#30693;
        {
            NetRequest* pReq1;
            while (NULL != (pReq1=m_Ctx.qWrite.pop_front())) {
                OnWritten(pContext-&gt;nErrCode, pReq1);
                Release();
            }
            while (NULL != (pReq1=m_Ctx.qRead.pop_front())) {
                OnRead(pContext-&gt;nErrCode, pReq1);
                Release();
            }
        }
        OnBroken(pContext-&gt;nErrCode);
        // AA_CONNECT also goes here
        if (nAction == AA_BROKEN)
            delete pReq;
        break;
    }
}
</pre>


</div>

</div>

<div id="outline-container-1-2-10-9" class="outline-5">
<h5 id="sec-1-2-10-9"><span class="section-number-5">1.2.10.9</span> Summary</h5>
<div class="outline-text-5" id="text-1-2-10-9">

<p>个人觉得kylin的网络异步部分就是spaghetti,所有的nAction以及nErrCode都是相互缠绕.我们可以假设我们的场景类似于RPC然后考虑一下应该如何处理。
</p><ul>
<li>OnConnected(APF_ERROR nErrCode).如果nErrCode!=APFE_OK的话那么Close,否则认为连接成功.错误交给OnBorken处理
</li>
<li>OnListened(SOCKET s, SOCKADDR_IN* pSockAddrIn).建立连接即可。
</li>
<li>OnWritten(APF_ERROR nErrCode, NetRequest* pReq).如果nErrCode!=APFE_OK的话，那么Close连接。
</li>
<li>OnRead(APF_ERROR nErrCode, NetRequest* pReq).如果nErrCode=APFE_NOTIFY的话那么发起Read,如果=APFE_OK的话那么处理，其他情况下面Close连接。
</li>
<li>OnBroken(APF_ERROR nErrCode).直接Close即可，但是可以根据nErrCode来判断原因.可能是客户端正常关闭.通常最后需要Release一下，释放这个连接。
</li>
</ul>

<p>关于具体使用的话可以仔细参考demo/echo.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> demo</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> echo</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>echo这个就是客户端连接上之后不断发送1K数据而服务器就直接回复这1K数据
</p>
</div>

<div id="outline-container-1-3-1-1" class="outline-5">
<h5 id="sec-1-3-1-1"><span class="section-number-5">1.3.1.1</span> client.cc</h5>
<div class="outline-text-5" id="text-1-3-1-1">




<pre class="src src-C++">/***************************************************************************
 *
 * Copyright (c) Baidu.com, Inc. All Rights Reserved
 *
 **************************************************************************/


/**
 * @author zhangyan04(@baidu.com)
 * @brief
 *
 */

#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;time.h&gt;
#include <span class="org-string">"stdafx.h"</span>
#include <span class="org-string">"Kylin.h"</span>
#include <span class="org-string">"Socket.h"</span>

#define ERR(fmt,...) fprintf(stderr,fmt,##__VA_ARGS__)
#define DBG(fmt,...) fprintf(stdout,fmt,##__VA_ARGS__)
//#define DBG(fmt,...)

static const int connect_timeout_ms=5*1000;
static const int CONNECT_TIMEOUT=AA_USER_BEGIN;
static const int read_timeout_ms=1200*1000;
static const int READ_TIMEOUT=AA_USER_BEGIN+1;
static const int worker_num=8;
static volatile int worker=worker_num;
static const int packet_size=1024;

class XAsyncClient:public CSocketV {
  public:
    int id;
    AsyncContext delay_ctx;
    char packet[packet_size];
    XAsyncClient(int id_):id(id_){
        AddRef();
        InitAsyncContext(&amp;delay_ctx);
        memset(packet,0xcc,packet_size);
    }
    ~XAsyncClient(){
    }
    void Print(){
        ERR(<span class="org-string">"(%d)xref:%d\n"</span>,id,CAsyncClient::GetRef());
    }
    void Close(){
        CSocketV::Close();
        atomic_add(&amp;worker,-1);
    }
    void StartConnnect(){
        APF_ERROR err=CSocketV::Create(true);
        if(err==APFE_OK){
            Connect(in_aton(<span class="org-string">"127.0.0.1"</span>),19870);
            // we don't need to AddRef() right here.
            g_pExecMan-&gt;DelayExec(CONNECT_TIMEOUT,this,connect_timeout_ms,&amp;delay_ctx);
        }else{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
        }
    }
    virtual void OnBroken(APF_ERROR nErrCode){
        ERR(<span class="org-string">"OnBroken(%s)\n"</span>,APFError2Str(nErrCode));
        Close();
        Release();
    }
    virtual bool OnConnected(APF_ERROR nErrCode){
        g_pExecMan-&gt;CancelExec(&amp;delay_ctx);
        if(nErrCode==APFE_OK){
            DBG(<span class="org-string">"APFE_OK OnConnected ready\n"</span>);
            Write(packet,packet_size,&amp;m_Req);
            return true;
        }else{
            ERR(<span class="org-string">"OnConnected(%s)\n"</span>,APFError2Str(nErrCode));
            return false;
        }
    }
    virtual void OnWritten(APF_ERROR nErrCode,NetRequest* req){
        if(nErrCode==APFE_OK){
            DBG(<span class="org-string">"APFE_OK OnWritten(%d)\n"</span>,req-&gt;xfered);
            Read(req-&gt;buf,req-&gt;xfered,&amp;m_Req);
            // we don't need to AddRef() right here.
            g_pExecMan-&gt;DelayExec(READ_TIMEOUT,this,read_timeout_ms,&amp;delay_ctx);
        }else{
            ERR(<span class="org-string">"OnWritten(%s)\n"</span>,APFError2Str(nErrCode));
            Close();
        }
}
    virtual void OnRead(APF_ERROR nErrCode,NetRequest* req){
        g_pExecMan-&gt;CancelExec(&amp;delay_ctx);
        if(nErrCode==APFE_OK){
            DBG(<span class="org-string">"APFE_OK OnRead(%d)\n"</span>,req-&gt;xfered);
            Write(req-&gt;buf,req-&gt;xfered,&amp;m_Req);
        }else{
            ERR(<span class="org-string">"OnRead(%s)\n"</span>,APFError2Str(nErrCode));
            Close();
        }
    }
    virtual void OnCompletion(AsyncContext* ctx){
        switch(ctx-&gt;nAction){
            case CONNECT_TIMEOUT:
                ERR(<span class="org-string">"connect timeout(%d ms)\n"</span>,connect_timeout_ms);
                Close();
                break;
            case READ_TIMEOUT:
                ERR(<span class="org-string">"read timeout(%d ms)\n"</span>,read_timeout_ms);
                Close();
                break;
            default:
                CSocketV::OnCompletion(ctx);
                break;
        }
    }
};

int main(){
    InitKylin(2,2,0);
    std::vector&lt; XAsyncClient* &gt; vec;
    for(int i=0;i&lt;worker_num;i++){
        XAsyncClient* client=new XAsyncClient(i);
        vec.push_back(client);
        client-&gt;StartConnnect();
    }
    // 100ms.
    const struct timespec timeout={0,100*1000000};
    while(1){
        nanosleep(&amp;timeout,NULL);
        if(AtomicGetValue(worker)==0){
            StopKylin(true);
            break;
        }
    }
    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-1-3-1-2" class="outline-5">
<h5 id="sec-1-3-1-2"><span class="section-number-5">1.3.1.2</span> server.cc</h5>
<div class="outline-text-5" id="text-1-3-1-2">




<pre class="src src-C++">/***************************************************************************
 *
 * Copyright (c) Baidu.com, Inc. All Rights Reserved
 *
 **************************************************************************/


/**
 * @author zhangyan04(@baidu.com)
 * @brief
 *
 */

#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;time.h&gt;
#include &lt;signal.h&gt;
#include <span class="org-string">"stdafx.h"</span>
#include <span class="org-string">"Kylin.h"</span>
#include <span class="org-string">"Socket.h"</span>

#define ERR(fmt,...) fprintf(stderr,fmt,##__VA_ARGS__)
#define DBG(fmt,...) fprintf(stdout,fmt,##__VA_ARGS__)
//#define DBG(fmt,...)

static volatile int client_id=-1;
static const int packet_size=1024;
static volatile int stop=0;
void signal_handler(int signo){
    AtomicSetValue(stop,1);
}

class XAsyncClient:public CSocketV {
  public:
    int id;
    AsyncContext delay_ctx;
    char packet[packet_size];
    XAsyncClient(int id_):id(id_){
        AddRef();
        InitAsyncContext(&amp;delay_ctx);
        memset(packet,0xcc,packet_size);
    }
    ~XAsyncClient(){
    }
    void Print(){
        fprintf(stderr,<span class="org-string">"(%d)xref:%d\n"</span>,id,CAsyncClient::GetRef());
    }
    void StartServe(){
        APF_ERROR err=CSocketV::Create(true,19870);
        if(err==APFE_OK){
            Listen();
        }else{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
        }
    }
    void OnListened(SOCKET s,SOCKADDR_IN* pSockAddrIn){
        XAsyncClient* client=new XAsyncClient(atomic_add(&amp;client_id,1));
        APF_ERROR err=client-&gt;Create(s,pSockAddrIn-&gt;sin_port);
        if(err==APFE_OK){
            ;
        }else{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
            Release();
        }
    }
    virtual void OnBroken(APF_ERROR nErrCode){
        ERR(<span class="org-string">"OnBroken(%s)\n"</span>,APFError2Str(nErrCode));
        Close();
        Release(); // we have to call 'Release' right here to free connection.
    }
    virtual void OnWritten(APF_ERROR nErrCode,NetRequest* req){
        switch(nErrCode){
            case APFE_OK:
                DBG(<span class="org-string">"APFE_OK OnWritten(%d)\n"</span>,req-&gt;xfered);
                Read(req-&gt;buf,req-&gt;xfered,&amp;m_Req);
                break;
            default:
                ERR(<span class="org-string">"OnWritten(%s)\n"</span>,APFError2Str(nErrCode));
                Close();
                break;
        }
    }
    virtual void OnRead(APF_ERROR nErrCode,NetRequest* req){
        switch(nErrCode){
            case APFE_NOTIFY:
                delete req;
                DBG(<span class="org-string">"APFE_NOTIFY OnRead ready\n"</span>);
                Read(packet,packet_size,&amp;m_Req);
                break;
            case APFE_OK:
                DBG(<span class="org-string">"APFE_OK OnRead(%d)\n"</span>,req-&gt;xfered);
                Write(req-&gt;buf,req-&gt;xfered,&amp;m_Req);
                break;
            default:
                ERR(<span class="org-string">"OnRead(%s)\n"</span>,APFError2Str(nErrCode));
                Close();
                break;
        }
    }
};

int main(){
    signal(SIGINT,signal_handler);
    InitKylin(2,2,0);
    XAsyncClient client(0);
    client.StartServe();
    // 100ms.
    const struct timespec timeout={0,100*1000000};
    while(1){
        nanosleep(&amp;timeout,NULL);
        if(AtomicGetValue(stop)==1){
            StopKylin(true);
            break;
        }
    }
    return 0;
}

</pre>


</div>
</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> file-request</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>file-request希望可以结合ExecMan,NetworkMan和DiskMan三个Manager写一个简单的demo,功能非常简单就是客户端每次发送一个文件名，服务端得到之后分析出文件名然后将内容返回给client.
消息格式都是头部带上了4个字节的长度，然后后面跟上数据。和之前的echo不同的是我们这里需要采取分段读取。
</p>
</div>

<div id="outline-container-1-3-2-1" class="outline-5">
<h5 id="sec-1-3-2-1"><span class="section-number-5">1.3.2.1</span> client.cc</h5>
<div class="outline-text-5" id="text-1-3-2-1">




<pre class="src src-C++">/***************************************************************************
 *
 * Copyright (c) Baidu.com, Inc. All Rights Reserved
 *
 **************************************************************************/


/**
 * @author zhangyan04(@baidu.com)
 * @brief
 *
 */

#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;time.h&gt;
#include <span class="org-string">"stdafx.h"</span>
#include <span class="org-string">"Kylin.h"</span>
#include <span class="org-string">"Socket.h"</span>

#define ERR(fmt,...) fprintf(stderr,fmt,##__VA_ARGS__)
#define DBG(fmt,...) fprintf(stdout,fmt,##__VA_ARGS__)
//#define DBG(fmt,...)

static const int connect_timeout_ms=5*1000;
static const int CONNECT_TIMEOUT=AA_USER_BEGIN;
static const int worker_num=1;
static volatile int worker=worker_num;
static const char* filename=<span class="org-string">"./file-server.cc"</span>;

class XAsyncClient:public CSocketV {
  public:
    int id;
    AsyncContext delay_ctx;
    enum status_t{
        READ_BOEY_LEN,
        READ_BODY_CONTENT,
    };
    status_t status;
    int read_body_len;
    XAsyncClient(int id_):id(id_){
        AddRef();
        InitAsyncContext(&amp;delay_ctx);
    }
    ~XAsyncClient(){
    }
    void Print(){
        ERR(<span class="org-string">"(%d)xref:%d\n"</span>,id,CAsyncClient::GetRef());
    }
    void Close(){
        CSocketV::Close();
        atomic_add(&amp;worker,-1);
    }
    void StartConnnect(){
        APF_ERROR err=CSocketV::Create(true);
        if(err==APFE_OK){
            Connect(in_aton(<span class="org-string">"127.0.0.1"</span>),19870);
            // we don't need to AddRef() right here.
            g_pExecMan-&gt;DelayExec(CONNECT_TIMEOUT,this,connect_timeout_ms,&amp;delay_ctx);
        }else{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
        }
    }
    virtual void OnBroken(APF_ERROR nErrCode){
        ERR(<span class="org-string">"OnBroken(%s)\n"</span>,APFError2Str(nErrCode));
        Close();
        Release();
    }
    int MakeFileRequest(const char* fname,char** request){
        int len=strlen(fname)+1; // include trailing '\0'
        char* tmp=(char*)malloc(len+4);
        *(int*)tmp=len;
        strcpy(tmp+sizeof(int),fname);
        *request=tmp;
        return len+4;
    }
    virtual bool OnConnected(APF_ERROR nErrCode){
        g_pExecMan-&gt;CancelExec(&amp;delay_ctx);
        if(nErrCode==APFE_OK){
            DBG(<span class="org-string">"OnConnected\n"</span>);
            char* request=NULL;
            int request_len=MakeFileRequest(filename,&amp;request);
            DBG(<span class="org-string">"MakeFileRequest (%s)(%d)\n"</span>,filename,request_len);
            Write(request,request_len,&amp;m_Req);
            return true;
        }else{
            ERR(<span class="org-string">"OnConnected(%s)\n"</span>,APFError2Str(nErrCode));
            return false;
        }
    }
    virtual void OnWritten(APF_ERROR nErrCode,NetRequest* req){
        free(req-&gt;buf);
        if(nErrCode==APFE_OK){
            DBG(<span class="org-string">"ReadBodyLen\n"</span>);
            status=READ_BOEY_LEN;
            Read(&amp;read_body_len,sizeof(read_body_len),&amp;m_Req);
        }else{
            ERR(<span class="org-string">"OnWritten(%s)\n"</span>,APFError2Str(nErrCode));
            Close();
        }
    }
    virtual void OnRead(APF_ERROR nErrCode,NetRequest* req){
        if(nErrCode==APFE_OK){
            if(status==READ_BOEY_LEN){
                DBG(<span class="org-string">"ReadBodyLen OK(%d)\n"</span>,read_body_len);
                char* tmp=(char*)malloc(read_body_len);
                status=READ_BODY_CONTENT;
                Read(tmp,read_body_len,&amp;m_Req);
            }else if(status==READ_BODY_CONTENT){
                free(req-&gt;buf);
                DBG(<span class="org-string">"ReadBodyContent OK\n"</span>);
                char* request=NULL;
                int request_len=MakeFileRequest(filename,&amp;request);
                DBG(<span class="org-string">"MakeFileRequest (%s)(%d)\n"</span>,filename,request_len);
                Write(request,request_len,&amp;m_Req);
            }
        }else{
            ERR(<span class="org-string">"OnRead(%s)\n"</span>,APFError2Str(nErrCode));
            Close();
        }
    }
    virtual void OnCompletion(AsyncContext* ctx){
        switch(ctx-&gt;nAction){
            case CONNECT_TIMEOUT:
                ERR(<span class="org-string">"connect timeout(%d ms)\n"</span>,connect_timeout_ms);
                Close();
                break;
            default:
                CSocketV::OnCompletion(ctx);
                break;
        }
    }
};

int main(){
    InitKylin(2,2,0);
    std::vector&lt; XAsyncClient* &gt; vec;
    for(int i=0;i&lt;worker_num;i++){
        XAsyncClient* client=new XAsyncClient(i);
        vec.push_back(client);
        client-&gt;StartConnnect();
    }
    // 100ms.
    const struct timespec timeout={0,100*1000000};
    while(1){
        nanosleep(&amp;timeout,NULL);
        if(AtomicGetValue(worker)==0){
            StopKylin(true);
            break;
        }
    }
    return 0;
}

</pre>


</div>

</div>

<div id="outline-container-1-3-2-2" class="outline-5">
<h5 id="sec-1-3-2-2"><span class="section-number-5">1.3.2.2</span> server.cc</h5>
<div class="outline-text-5" id="text-1-3-2-2">




<pre class="src src-C++">/***************************************************************************
 *
 * Copyright (c) Baidu.com, Inc. All Rights Reserved
 *
 **************************************************************************/


/**
 * @author zhangyan04(@baidu.com)
 * @brief
 *
 */

#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;time.h&gt;
#include &lt;signal.h&gt;
#include <span class="org-string">"stdafx.h"</span>
#include <span class="org-string">"Kylin.h"</span>
#include <span class="org-string">"Socket.h"</span>

#define ERR(fmt,...) fprintf(stderr,fmt,##__VA_ARGS__)
#define DBG(fmt,...) fprintf(stdout,fmt,##__VA_ARGS__)
//#define DBG(fmt,...)

static volatile int client_id=-1;
static volatile int stop=0;
static const int disk_thread_num=4;

void signal_handler(int signo){
    AtomicSetValue(stop,1);
}

class XAsyncClient:public CSocketV {
  public:
    int id;
    AsyncContext delay_ctx;
    DiskContext disk_ctx;
    DiskRequest disk_req;
    enum status_t{
        READ_BODY_LEN,
        READ_BODY_CONTENT,
    };
    status_t status;
    int read_body_len;
    char* reply;
    int reply_len;
    XAsyncClient(int id_):id(id_){
        AddRef();
        InitAsyncContext(&amp;delay_ctx);
    }
    ~XAsyncClient(){
    }
    void Print(){
        fprintf(stderr,<span class="org-string">"(%d)xref:%d\n"</span>,id,CAsyncClient::GetRef());
    }
    void StartServe(){
        APF_ERROR err=CSocketV::Create(true,19870);
        if(err==APFE_OK){
            Listen();
        }else{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
        }
    }
    void OnListened(SOCKET s,SOCKADDR_IN* pSockAddrIn){
        DBG(<span class="org-string">"OnListened\n"</span>);
        XAsyncClient* client=new XAsyncClient(atomic_add(&amp;client_id,1));
        APF_ERROR err=client-&gt;Create(s,pSockAddrIn-&gt;sin_port);
        if(err==APFE_OK){
            ;
        }else{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
            Release();
        }
    }
    virtual void OnBroken(APF_ERROR nErrCode){
        ERR(<span class="org-string">"OnBroken(%s)\n"</span>,APFError2Str(nErrCode));
        Close();
        Release(); // we have to call 'Release' right here to free connection.
    }
    virtual void OnWritten(APF_ERROR nErrCode,NetRequest* req){
        free(req-&gt;buf);
        switch(nErrCode){
            case APFE_OK:
                DBG(<span class="org-string">"OnWritten\n"</span>);
                status=READ_BODY_LEN;
                Read(&amp;read_body_len,sizeof(read_body_len),&amp;m_Req);
                break;
            default:
                ERR(<span class="org-string">"OnWritten(%s)\n"</span>,APFError2Str(nErrCode));
                Close();
                break;
        }
    }
    virtual void OnRead(APF_ERROR nErrCode,NetRequest* req){
        switch(nErrCode){
            case APFE_NOTIFY:
                delete req;
                DBG(<span class="org-string">"OnRead APFE_NOTIFY\n"</span>);
                status=READ_BODY_LEN;
                Read(&amp;read_body_len,sizeof(read_body_len),&amp;m_Req);
                break;
            case APFE_OK:
                if(status==READ_BODY_LEN){
                    DBG(<span class="org-string">"ReadBodyLen OK(%d)\n"</span>,read_body_len);
                    char* request=(char*)malloc(read_body_len);
                    status=READ_BODY_CONTENT;
                    Read(request,read_body_len,&amp;m_Req);
                }else if(status==READ_BODY_CONTENT){
                    DBG(<span class="org-string">"ReadBodyContent OK(%s)\n"</span>,req-&gt;buf);
                    int fd=open((char*)req-&gt;buf,O_RDONLY,0666);
                    free(req-&gt;buf);

                    // init disk read.
                    struct stat st_buf;
                    fstat(fd,&amp;st_buf);
                    reply_len=sizeof(int)+st_buf.st_size;
                    reply=(char*)malloc(reply_len);
                    *(int*)reply=(int)st_buf.st_size;
                    g_pDiskMan-&gt;Associate(id%disk_thread_num,fd,this,&amp;disk_ctx);
                    DBG(<span class="org-string">"ReadDiskContent (%d)\n"</span>,reply_len-sizeof(int));
                    disk_req.off=0; // read from beginning.
                    g_pDiskMan-&gt;Read(&amp;disk_ctx,reply+sizeof(int),reply_len-sizeof(int),&amp;disk_req);
                }
                break;
            default:
                ERR(<span class="org-string">"OnRead(%s)\n"</span>,APFError2Str(nErrCode));
                Close();
                break;
        }
    }
    virtual void OnCompletion(AsyncContext* ctx){
        if(ctx==&amp;(disk_req.async)){
            assert(ctx-&gt;nAction==AA_READ); // disk read done.
            DBG(<span class="org-string">"request %d, xfered %d %s\n"</span>,disk_req.request,disk_req.xfered,APFError2Str(ctx-&gt;nErrCode));
            assert(disk_req.request==disk_req.xfered);
            g_pDiskMan-&gt;Deassociate(&amp;disk_ctx);
            close(disk_ctx.fd);
            Write(reply,reply_len,&amp;m_Req);
        }else{
            CSocketV::OnCompletion(ctx);
        }
    }
};

int main(){
    signal(SIGINT,signal_handler);
    InitKylin(2,2,disk_thread_num);
    XAsyncClient client(0);
    client.StartServe();
    // 100ms.
    const struct timespec timeout={0,100*1000000};
    while(1){
        nanosleep(&amp;timeout,NULL);
        if(AtomicGetValue(stop)==1){
            StopKylin(true);
            break;
        }
    }
    return 0;
}

</pre>

</div>
</div>
</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-01-02T19:57+0800</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.2 with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
<!-- Baidu Analytics BEGIN --><script type="text/javascript">var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F54a700ad7035f6e485eaf2300641e7e9' type='text/javascript'%3E%3C/script%3E"));</script><!-- Baidu Analytics END --><!-- Google Analytics BEGIN --><!-- <script type="text/javascript">  var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-31377772-1']);  _gaq.push(['_trackPageview']);  (function() {    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);  })();</script> --><!-- Google Analytics END --><!-- Baidu Button BEGIN --><!-- <script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6762177" ></script><script type="text/javascript" id="bdshell_js"></script><script type="text/javascript"> document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)</script> --><!-- Baidu Button END --><!-- G+ BEGIN --><!-- Place this render call where appropriate --><!-- <script type="text/javascript">  (function() {    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;    po.src = 'https://apis.google.com/js/plusone.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);  })();</script> --><!-- G+ END --><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * *//* required: replace example with your forum shortname  */var disqus_shortname = 'feiskyblog';var disqus_identifier = 'kylin.html';var disqus_title = 'kylin.html';var disqus_url = 'http://blog.com/kylin.html';/* * * DON'T EDIT BELOW THIS LINE * * */(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><!-- DISQUS END --></body>
</html>
