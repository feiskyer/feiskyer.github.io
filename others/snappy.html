layout: false
---
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><!-- <meta name="baidu-site-verification" content="707024a76f8f40b549f07f478abab237"/> -->
<title>snappy</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="snappy"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-01-02T19:56+0800"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="shortcut icon" href="http://blog.com/css/favicon.ico" /> <link rel="stylesheet" type="text/css" href="./css/site.css" />


</head>
<body><!-- <div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare"><a class="bds_tsina"></a><span class="bds_more"></span><a class="shareCount"></a></div> --><!-- Place this tag where you want the +1 button to render --><!-- <g:plusone annotation="inline"></g:plusone> -->

<div id="preamble">

</div>

<div id="content">
<h1 class="title">snappy</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 snappy</a>
<ul>
<li><a href="#sec-1-1">1.1 Format</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1 Literal</a></li>
<li><a href="#sec-1-1-2">1.1.2 Copy</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2 Source &amp; Sink</a></li>
<li><a href="#sec-1-3">1.3 Snippet</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1 Bits</a></li>
<li><a href="#sec-1-3-2">1.3.2 Varint</a></li>
<li><a href="#sec-1-3-3">1.3.3 GetUint32AtOffset</a></li>
<li><a href="#sec-1-3-4">1.3.4 GetHashTable</a></li>
<li><a href="#sec-1-3-5">1.3.5 FindMatchLength</a></li>
<li><a href="#sec-1-3-6">1.3.6 MaxCompressedLength</a></li>
<li><a href="#sec-1-3-7">1.3.7 IncrementalCopy</a></li>
<li><a href="#sec-1-3-8">1.3.8 EmitLiteral</a></li>
<li><a href="#sec-1-3-9">1.3.9 EmitCopy</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4 Compress</a></li>
<li><a href="#sec-1-5">1.5 Uncompress</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1 Writer</a></li>
<li><a href="#sec-1-5-2">1.5.2 SnappyDecompressor</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6 Example</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> snappy</h2>
<div class="outline-text-2" id="text-1">


<p>
<a href="http://code.google.com/p/snappy/">http://code.google.com/p/snappy/</a>
</p>
<p>
Snappy is a compression/decompression library. It does not aim for maximum
compression, or compatibility with any other compression library; instead,
it aims for very high speeds and reasonable compression. For instance,
compared to the fastest mode of zlib, Snappy is an order of magnitude faster
for most inputs, but the resulting compressed files are anywhere from 20% to
100% bigger. (For more information, see "Performance", below.)
</p>
<p>
Snappy is intended to be fast. On a single core of a Core i7 processor
in 64-bit mode, it compresses at about 250 MB/sec or more and decompresses at
about 500 MB/sec or more. (These numbers are for the slowest inputs in our
benchmark suite; others are much faster.) In our tests, Snappy usually
is faster than algorithms in the same class (e.g. LZO, LZF, FastLZ, QuickLZ,
etc.) while achieving comparable compression ratios.
</p>
<p>
Typical compression ratios (based on the benchmark suite) are about 1.5-1.7x
for plain text, about 2-4x for HTML, and of course 1.0x for JPEGs, PNGs and
other already-compressed data. Similar numbers for zlib in its fastest mode
are 2.6-2.8x, 3-7x and 1.0x, respectively. More sophisticated algorithms are
capable of achieving yet higher compression rates, although usually at the
expense of speed. Of course, compression ratio will vary significantly with
the input.
</p>
<p>
Snappy里面大部分操作都是针对32/64位数据操作，然后假设不对齐的32/64位数据载入开销很少。
同时假设CPU字节序是little-endian.也有big-endian实现但是速度相对较慢。对于Intel处理器就非常适用。
</p>
<p>
Although Snappy should be fairly portable, it is primarily optimized
for 64-bit x86-compatible processors, and may run slower in other environments.
In particular:
</p><ul>
<li>Snappy uses 64-bit operations in several places to process more data at
   once than would otherwise be possible.
</li>
<li>Snappy assumes unaligned 32- and 64-bit loads and stores are cheap.
   On some platforms, these must be emulated with single-byte loads
   and stores, which is much slower.
</li>
<li>Snappy assumes little-endian throughout, and needs to byte-swap data in
   several places if running on a big-endian platform.
</li>
</ul>



</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Format</h3>
<div class="outline-text-3" id="text-1-1">

<p>Snappy is a LZ77-type compressor with a fixed, byte-oriented encoding.
</p>
<p>
压缩的头部是一个原始串长度，然后使用变长整数方式来编码(google::protobuf也使用)
</p>
<p>
The stream starts with the uncompressed length (up to a maximum of 2^32 - 1),
stored as a little-endian varint. Varints consist of a series of bytes,
where the lower 7 bits are data and the upper bit is set iff there are
more bytes to be read. In other words, an uncompressed length of 64 would
be stored as 0x40, and an uncompressed length of 2097151 (0x1FFFFF)
would be stored as 0xFF 0xFF 0x7F.
</p>
<p>
对于LZ77类型的压缩算法说里面包含两个部分
</p><ul>
<li>literal(字表).这个表示原始内容
</li>
<li>copy(拷贝).这个表示针对原始内容的copy.
</li>
</ul>

<p>对于LZ77类型压缩类型，所谓的copy无非就是(offset,length).然后通过精巧的编码方式将(offset,length)写入。
通常来说编码方式会比原始内容小，这样达到压缩目的。而literal和copy本身也通过编码方式来进行区分，第一个字节
低两位00表示literal,而01,10,11分别表示不同类型的copy.
</p>
<p>
Snappy实现上来说非常简单，首先针对字节流进行分块(比如32KB,现在实现就是这样的，当然可以小于32KB).针对每个32KB都压缩称为
(literal+ copy+)* literal+这样的模式。解压起来也非常简单，首先将Literal解压缩copy到output字节流里面去，然后根据后面的copy
配合之前输出的output解压出来。
</p>

</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Literal</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>对于literal来说的话编码方式是这样的，假设literal的长度为len(len&gt;=1).
</p><ul>
<li>如果len&lt;=60.那么literal使用一个字节表示(len-1) &lt;&lt; 2 | 0x0 (1个字节)
</li>
<li>如果len可以用1个字节表示的话，那么literal表示[60 &lt;&lt; 2 | 0x0, len](2个字节)
</li>
<li>如果len可以用2个字节表示的话，那么literal表示[61 &lt;&lt; 2 | 0x0, len](3个字节).
</li>
<li>如果len可以用3个字节表示的话，那么literal表示[62 &lt;&lt; 2 | 0x0, len](4个字节).
</li>
<li>如果len可以用4个字节表示的话，那么literal表示[63 &lt;&lt; 2 | 0x0, len](5个字节).
</li>
</ul>

<p>注意这里len都是按照小端序写入的。
</p>
</div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> Copy</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>对于copy来说的话我们假设内容是(offset,length).(offset&gt;=1,length&gt;=1).
</p><ul>
<li>如果length在[4,11],而offset在[0,2047].那么表示[(offset &gt;&gt; 8) &lt;&lt; 5 | (length-4) &lt;&lt;2 | 0x01 , offset &amp; 0xff](2个字节)
</li>
<li>如果length在[1,64],而offset在[0,65535],那么表示[(length-1) &lt;&lt; 2 | 0x02 , offset](3个字节)
</li>
<li>如果length在[1,64],而offset在[0,2^32-1],那么表示[(length-1) &lt;&lt; 2 | 0x03, offset](5个字节)
</li>
</ul>

<p>我们这里注意到length都在[1,64]之间，如果length&gt;64的话。那么我们可以将copy切分。这个在代码里面可以看到。
</p>
</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Source &amp; Sink</h3>
<div class="outline-text-3" id="text-1-2">

<p>这里Source表示输入源，而Sink表示输出源。不过设计上比较遗憾的是在Compress上面使用了这两个结构，
而在Uncompress上面的话只是使用了Source这个结构，而输出源的话使用了另外一个内部类Writer.
</p>


<pre class="src src-C++">size_t Compress(Source* source, Sink* sink);
bool RawUncompress(Source* compressed, char* uncompressed); // &#20869;&#37096;&#26377;&#19968;&#20010;Writer&#23553;&#35013;&#20102;uncompressed&#25805;&#20316;
</pre>


<p>
我们首先看看Sink定义的接口。能够理解这个接口全依赖这个清晰的注释。其中
</p><ul>
<li>Append接口的话是将bytes[0,n-1]这个字节流写入。
</li>
<li>GetAppendBuffer的话是交出一块length的buffer。这块length的buffer的话必须一致有效直到Append被调用。当然我们也可以直接返回scratch(外围框架分配的内存).
</li>
</ul>




<pre class="src src-C++">// A Sink is an interface that consumes a sequence of bytes.
class Sink {
 public:
  Sink() { }
  virtual ~Sink();

  // Append <span class="org-string">"bytes[0,n-1]"</span> to this.
  virtual void Append(const char* bytes, size_t n) = 0;

  // Returns a writable buffer of the specified length for appending.
  // May return a pointer to the caller-owned scratch buffer which
  // must have at least the indicated length.  The returned buffer is
  // only valid until the next operation on this Sink.
  //
  // After writing at most <span class="org-string">"length"</span> bytes, call Append() with the
  // pointer returned from this function and the number of bytes
  // written.  Many Append() implementations will avoid copying
  // bytes if this function returned an internal buffer.
  //
  // If a non-scratch buffer is returned, the caller may only pass a
  // prefix of it to Append().  That is, it is not correct to pass an
  // interior pointer of the returned array to Append().
  //
  // The default implementation always returns the scratch buffer.
  virtual char* GetAppendBuffer(size_t length, char* scratch);

 private:
  // No copying
  Sink(const Sink&amp;);
  void operator=(const Sink&amp;);
};
</pre>


<p>
然后看看snappy默认实现Sink接口。这里GetAppendBuffer并没有使用scratch而是直接返回dest_,这样的话可以减少1次copy.因为如果返回scratch的话，那么外部框架首先copy到scratch,然后从scratch在copy回dest_.所以这里为什么Append需要判断(data!=dest_).
</p>


<pre class="src src-C++">// A Sink implementation that writes to a flat array without any bound checks.
class UncheckedByteArraySink : public Sink {
 public:
  explicit UncheckedByteArraySink(char* dest) : dest_(dest) { }
  virtual ~UncheckedByteArraySink();
  virtual void Append(const char* data, size_t n);
  virtual char* GetAppendBuffer(size_t len, char* scratch);

  // Return the current output pointer so that a caller can see how
  // many bytes were produced.
  // Note: this is not a Sink method.
  char* CurrentDestination() const { return dest_; }
 private:
  char* dest_;
};

void UncheckedByteArraySink::Append(const char* data, size_t n) {
  // Do no copying if the caller filled in the result of GetAppendBuffer()
  if (data != dest_) {
    memcpy(dest_, data, n);
  }
  dest_ += n;
}

char* UncheckedByteArraySink::GetAppendBuffer(size_t len, char* scratch) {
  return dest_;
}
</pre>

<p>
其实这个Sink接口非常简单地重定向到其他部分比如文件，这个在Example里面会给出例子。
</p>
<p>
接着我们看看Source定义的接口。同样能够理解这个接口全依赖清晰的注释。其中
</p><ul>
<li>Available表示还有多少个字节剩余。
</li>
<li>Peek是返回前面可以窥探到的字节流，并且返回长度。返回的buffer必须持续有效直到Skip.
</li>
<li>Skip相当于告诉Source某个部分的字节流已经不需要被使用了。
</li>
</ul>




<pre class="src src-C++">// A Source is an interface that yields a sequence of bytes
class Source {
 public:
  Source() { }
  virtual ~Source();

  // Return the number of bytes left to read from the source
  virtual size_t Available() const = 0;

  // Peek at the next flat region of the source.  Does not reposition
  // the source.  The returned region is empty iff Available()==0.
  //
  // Returns a pointer to the beginning of the region and store its
  // length in *len.
  //
  // The returned region is valid until the next call to Skip() or
  // until this object is destroyed, whichever occurs first.
  //
  // The returned region may be larger than Available() (for example
  // if this ByteSource is a view on a substring of a larger source).
  // The caller is responsible for ensuring that it only reads the
  // Available() bytes.
  virtual const char* Peek(size_t* len) = 0;

  // Skip the next n bytes.  Invalidates any buffer returned by
  // a previous call to Peek().
  // REQUIRES: Available() &gt;= n
  virtual void Skip(size_t n) = 0;

 private:
  // No copying
  Source(const Source&amp;);
  void operator=(const Source&amp;);
};
</pre>

<p>
然后snappy的默认实现非常简单
</p>


<pre class="src src-C++">// A Source implementation that yields the contents of a flat array
class ByteArraySource : public Source {
 public:
  ByteArraySource(const char* p, size_t n) : ptr_(p), left_(n) { }
  virtual ~ByteArraySource();
  virtual size_t Available() const;
  virtual const char* Peek(size_t* len);
  virtual void Skip(size_t n);
 private:
  const char* ptr_;
  size_t left_;
};

size_t ByteArraySource::Available() const { return left_; }

const char* ByteArraySource::Peek(size_t* len) {
  *len = left_;
  return ptr_;
}

void ByteArraySource::Skip(size_t n) {
  left_ -= n;
  ptr_ += n;
}
</pre>

<p>
从Source接口上来看到的话并不是非常好扩展。因为一开始必须知道串有多大并且从代码上看Snappy并不是一个可以增量压缩的东西。
所以个人感觉来说Source只能够做内存buffer的封装而不能够包装磁盘或者是网络流。
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Snippet</h3>
<div class="outline-text-3" id="text-1-3">

<p>Snappy里面有相当多的代码片段非常精巧(一定程度上难懂)，所以有必要首先看看这些函数实现。
</p>

</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> Bits</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>定义了一些位操作，都使用了gcc内置函数
</p>


<pre class="src src-C++">// Some bit-manipulation functions.
class Bits {
 public:
  // Return floor(log2(n)) for positive integer n.  Returns -1 iff n == 0.
  static int Log2Floor(uint32 n);

  // Return the first set least / most significant bit, 0-indexed.  Returns an
  // undefined value if n == 0.  FindLSBSetNonZero() is similar to ffs() except
  // that it's 0-indexed.
  static int FindLSBSetNonZero(uint32 n);
  static int FindLSBSetNonZero64(uint64 n);

 private:
  DISALLOW_COPY_AND_ASSIGN(Bits);
};

inline int Bits::Log2Floor(uint32 n) {
  return n == 0 ? -1 : 31 ^ __builtin_clz(n); // &#21482;&#26159;&#21462;&#20302;5&#20301;&#21363;&#21487;
}

inline int Bits::FindLSBSetNonZero(uint32 n) {
  return __builtin_ctz(n);
}

inline int Bits::FindLSBSetNonZero64(uint64 n) {
  return __builtin_ctzll(n);
}
</pre>


<p>
为了方便这里给出三个内置函数解释
</p><ul>
<li>int __builtin_clz (unsigned int x) // Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.
</li>
<li>int __builtin_ctz (unsigned int x) // Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.
</li>
<li>int __builtin_clzll (unsigned long long) // Similar to __builtin_clz, except the argument type is unsigned long long.
</li>
</ul>


</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> Varint</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>定义了如何将32位整数进行编码和解码。关于这种编码方式可以参考protobuf的链接
<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/encoding.html#varints">http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/encoding.html#varints</a>
</p>


<pre class="src src-C++">// Variable-length integer encoding.
class Varint {
 public:
  // Maximum lengths of varint encoding of uint32.
  static const int kMax32 = 5;

  // Attempts to parse a varint32 from a prefix of the bytes in [ptr,limit-1].
  // Never reads a character at or beyond limit.  If a valid/terminated varint32
  // was found in the range, stores it in *OUTPUT and returns a pointer just
  // past the last byte of the varint32. Else returns NULL.  On success,
  // <span class="org-string">"result &lt;= limit"</span>.
  static const char* Parse32WithLimit(const char* ptr, const char* limit,
                                      uint32* OUTPUT);

  // REQUIRES   <span class="org-string">"ptr"</span> points to a buffer of length sufficient to hold <span class="org-string">"v"</span>.
  // EFFECTS    Encodes <span class="org-string">"v"</span> into <span class="org-string">"ptr"</span> and returns a pointer to the
  //            byte just past the last encoded byte.
  static char* Encode32(char* ptr, uint32 v);

  // EFFECTS    Appends the varint representation of <span class="org-string">"value"</span> to <span class="org-string">"*s"</span>.
  static void Append32(string* s, uint32 value);
};

inline const char* Varint::Parse32WithLimit(const char* p,
                                            const char* l,
                                            uint32* OUTPUT) {
  const unsigned char* ptr = reinterpret_cast&lt;const unsigned char*&gt;(p);
  const unsigned char* limit = reinterpret_cast&lt;const unsigned char*&gt;(l);
  uint32 b, result;
  if (ptr &gt;= limit) return NULL;
  b = *(ptr++); result = b &amp; 127;          if (b &lt; 128) goto done;
  if (ptr &gt;= limit) return NULL;
  b = *(ptr++); result |= (b &amp; 127) &lt;&lt;  7; if (b &lt; 128) goto done;
  if (ptr &gt;= limit) return NULL;
  b = *(ptr++); result |= (b &amp; 127) &lt;&lt; 14; if (b &lt; 128) goto done;
  if (ptr &gt;= limit) return NULL;
  b = *(ptr++); result |= (b &amp; 127) &lt;&lt; 21; if (b &lt; 128) goto done;
  if (ptr &gt;= limit) return NULL;
  b = *(ptr++); result |= (b &amp; 127) &lt;&lt; 28; if (b &lt; 16) goto done;
  return NULL;       // Value is too long to be a varint32
 done:
  *OUTPUT = result;
  return reinterpret_cast&lt;const char*&gt;(ptr);
}

inline char* Varint::Encode32(char* sptr, uint32 v) {
  // Operate on characters as unsigneds
  unsigned char* ptr = reinterpret_cast&lt;unsigned char*&gt;(sptr);
  static const int B = 128;
  if (v &lt; (1&lt;&lt;7)) {
    *(ptr++) = v;
  } else if (v &lt; (1&lt;&lt;14)) {
    *(ptr++) = v | B;
    *(ptr++) = v&gt;&gt;7;
  } else if (v &lt; (1&lt;&lt;21)) {
    *(ptr++) = v | B;
    *(ptr++) = (v&gt;&gt;7) | B;
    *(ptr++) = v&gt;&gt;14;
  } else if (v &lt; (1&lt;&lt;28)) {
    *(ptr++) = v | B;
    *(ptr++) = (v&gt;&gt;7) | B;
    *(ptr++) = (v&gt;&gt;14) | B;
    *(ptr++) = v&gt;&gt;21;
  } else {
    *(ptr++) = v | B;
    *(ptr++) = (v&gt;&gt;7) | B;
    *(ptr++) = (v&gt;&gt;14) | B;
    *(ptr++) = (v&gt;&gt;21) | B;
    *(ptr++) = v&gt;&gt;28;
  }
  return reinterpret_cast&lt;char*&gt;(ptr);
}

void Varint::Append32(string* s, uint32 value) {
  char buf[Varint::kMax32];
  const char* p = Varint::Encode32(buf, value);
  s-&gt;append(buf, p - buf);
}

</pre>


</div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> GetUint32AtOffset</h4>
<div class="outline-text-4" id="text-1-3-3">

<p>能够从一个uint64里面取出任意偏移的uint32。通常我们一次载入一个uint64的话那么知道可以得到5个uint32,效率会很高。
</p>


<pre class="src src-C++">// For 0 &lt;= offset &lt;= 4, GetUint32AtOffset(UNALIGNED_LOAD64(p), offset) will
// equal UNALIGNED_LOAD32(p + offset).  Motivation: On x86-64 hardware we have
// empirically found that overlapping loads such as
//  UNALIGNED_LOAD32(p) ... UNALIGNED_LOAD32(p+1) ... UNALIGNED_LOAD32(p+2)
// are slower than UNALIGNED_LOAD64(p) followed by shifts and casts to uint32.
static inline uint32 GetUint32AtOffset(uint64 v, int offset) {
  DCHECK(0 &lt;= offset &amp;&amp; offset &lt;= 4) &lt;&lt; offset;
  return v &gt;&gt; (LittleEndian::IsLittleEndian() ? 8 * offset : 32 - 8 * offset);
}
</pre>


</div>

</div>

<div id="outline-container-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> GetHashTable</h4>
<div class="outline-text-4" id="text-1-3-4">

<p>在Compress的时候需要得到HashTable来判断哪些地方可以得到copy.不过实话说GetHashTable其实没有太多可以值得学习的地方，但是我们还是看看吧。
至于hashtable每一个entry都是uint16表示什么东西，这个在Compress函数里面会讲到
</p>



<pre class="src src-C++">// &#22240;&#20026;Compress&#26159;&#25353;&#29031;1&#20010;&#20010;chunk&#26469;&#36827;&#34892;&#21387;&#32553;&#30340;&#65292;input_size&#34920;&#31034;&#36825;&#20010;chunk&#22823;&#23567;&#22810;&#23569;
// &#29616;&#22312;&#26469;&#30475;&#30340;&#35805;chunk&#26368;&#22823;32KB&#12290;&#28982;&#21518;table_size&#34920;&#31034;hashtable&#26742;&#22823;&#23567;&#12290;

uint16* WorkingMemory::GetHashTable(size_t input_size, int* table_size) {
  // Use smaller hash table when input.size() is smaller, since we
  // fill the table, incurring O(hash table size) overhead for
  // compression, and if the input is short, we won't need that
  // many hash table entries anyway.
  assert(kMaxHashTableSize &gt;= 256);
  int htsize = 256; // &#39318;&#20808;&#20174;&#26742;&#22823;&#23567;256&#24320;&#22987;&#36827;&#34892;&#35843;&#33410;,*2&#30452;&#21040;&gt;=input_size&#25110;&#32773;&#26159;kMaxHashTableSize
  while (htsize &lt; kMaxHashTableSize &amp;&amp; htsize &lt; input_size) {
    htsize &lt;&lt;= 1;
  }
  CHECK_EQ(0, htsize &amp; (htsize - 1)) &lt;&lt; <span class="org-string">": must be power of two"</span>;
  CHECK_LE(htsize, kMaxHashTableSize) &lt;&lt; <span class="org-string">": hash table too large"</span>;

  uint16* table;
  if (htsize &lt;= ARRAYSIZE(small_table_)) { // &#23545;&#20110;WorkingMemory&#20869;&#37096;&#26377;&#19968;&#20010;small_table_[1&lt;&lt;10],&#36825;&#26679;&#21487;&#20197;&#20943;&#23569;&#20998;&#37197;&#20195;&#20215;
    table = small_table_;
  } else {
    if (large_table_ == NULL) {
      large_table_ = new uint16[kMaxHashTableSize]; // &#23545;&#20110;&#22823;&#26742;&#30340;&#35805;&#37027;&#20040;&#25105;&#20204;&#38656;&#35201;new&#20986;&#26469;
    }
    table = large_table_;
  }

  *table_size = htsize;
  memset(table, 0, htsize * sizeof(*table)); // memset(0)&#26159;&#38656;&#35201;&#30340;&#65292;&#22312;Compress&#37096;&#20998;&#21487;&#20197;&#30475;&#21040;&#20026;&#20160;&#20040;&#38656;&#35201;&#28165;0.
  return table;
}
</pre>


</div>

</div>

<div id="outline-container-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> FindMatchLength</h4>
<div class="outline-text-4" id="text-1-3-5">

<p>为了快速找到两个串(s1,s2)最大匹配长度多少，其中s2_limit表示s2的结尾返回匹配长度。引用场景下面s1和s2是同一个串，不过(s1&lt;s2)因为我们不需要判断s1溢出。
</p>


<pre class="src src-C++">// Return the largest n such that
//
//   s1[0,n-1] == s2[0,n-1]
//   and n &lt;= (s2_limit - s2).
//
// Does not read *s2_limit or beyond.
// Does not read *(s1 + (s2_limit - s2)) or beyond.
// Requires that s2_limit &gt;= s2.

static inline int FindMatchLength(const char* s1,
                                  const char* s2,
                                  const char* s2_limit) {
  DCHECK_GE(s2_limit, s2);
  int matched = 0;

  // Find out how long the match is. We loop over the data 64 bits at a
  // time until we find a 64-bit block that doesn't match; then we find
  // the first non-matching bit and use that to calculate the total
  // length of the match.
  while (PREDICT_TRUE(s2 &lt;= s2_limit - 8)) { // &#22914;&#26524;s2&#36824;&#26377;8&#20010;&#20197;&#19978;&#23383;&#33410;&#30340;&#35805;
    if (PREDICT_FALSE(UNALIGNED_LOAD64(s2) == UNALIGNED_LOAD64(s1 + matched))) { // &#37027;&#20040;&#25105;&#20204;&#39318;&#20808;8&#20010;&#23383;&#33410;&#36827;&#34892;&#27604;&#36739;&#65292;&#21305;&#37197;&#19978;&#30340;&#35805;+8
      s2 += 8;
      matched += 8;
    } else { // &#22914;&#26524;&#19981;&#21305;&#37197;&#30340;&#35805;&#65292;&#37027;&#20040;&#25105;&#20204;&#21487;&#20197;&#36890;&#36807;xor&#26469;&#21028;&#26029;&#12290;&#22914;&#26524;&#30456;&#21516;&#30340;&#35805;&#20026;0,&#28982;&#21518;&#20174;LSB&#21028;&#26029;&#26377;&#22810;&#23569;&#20010;0&#65292;&#28982;&#21518;count &gt;&gt; 3&#23601;&#34920;&#31034;&#21305;&#37197;&#23383;&#33410;&#12290;&#38750;&#24120;&#24039;&#22937;&#12290;
      // On current (mid-2008) Opteron models there is a 3% more
      // efficient code sequence to find the first non-matching byte.
      // However, what follows is ~10% better on Intel Core 2 and newer,
      // and we expect AMD's bsf instruction to improve.
      uint64 x = UNALIGNED_LOAD64(s2) ^ UNALIGNED_LOAD64(s1 + matched);
      int matching_bits = Bits::FindLSBSetNonZero64(x);
      matched += matching_bits &gt;&gt; 3;
      return matched;
    }
  }
  while (PREDICT_TRUE(s2 &lt; s2_limit)) { // &#22914;&#26524;&#27809;&#26377;8&#20010;&#23383;&#33410;&#30340;&#35805;&#37027;&#20040;&#20043;&#21518;&#33021;&#22815;1&#20010;&#23383;&#33410;&#36880;&#20010;&#21305;&#37197;&#12290;
    if (PREDICT_TRUE(s1[matched] == *s2)) {
      ++s2;
      ++matched;
    } else {
      return matched;
    }
  }
  return matched;
}
</pre>


</div>

</div>

<div id="outline-container-1-3-6" class="outline-4">
<h4 id="sec-1-3-6"><span class="section-number-4">1.3.6</span> MaxCompressedLength</h4>
<div class="outline-text-4" id="text-1-3-6">

<p>snappy接口简单很大长度上是因为对于一个input串的话，可以根据input串估计出compress之后的串长度上限。
然后进行压缩之前可以进行预分配，然后snappy内部的话在进行压缩时候就不进行字符越界检查了。
通常牺牲部分内存来达到接口简单易用非常好。对于具体分析的话注释里面都写出来了，我们可以仔细分析copy以及literal带来的膨胀代价，
但是这里并不打算仔细分析。TODO(zhangyan04):还不知道32是什么意思？但是为了放置长度在头部也确实需要几个额外字节。
</p>



<pre class="src src-C++">size_t MaxCompressedLength(size_t source_len) {
  // Compressed data can be defined as:
  //    compressed := item* literal*
  //    item       := literal* copy
  //
  // The trailing literal sequence has a space blowup of at most 62/60
  // since a literal of length 60 needs one tag byte + one extra byte
  // for length information.
  //
  // Item blowup is trickier to measure.  Suppose the <span class="org-string">"copy"</span> op copies
  // 4 bytes of data.  Because of a special check in the encoding code,
  // we produce a 4-byte copy only if the offset is &lt; 65536.  Therefore
  // the copy op takes 3 bytes to encode, and this type of item leads
  // to at most the 62/60 blowup for representing literals.
  //
  // Suppose the <span class="org-string">"copy"</span> op copies 5 bytes of data.  If the offset is big
  // enough, it will take 5 bytes to encode the copy op.  Therefore the
  // worst case here is a one-byte literal followed by a five-byte copy.
  // I.e., 6 bytes of input turn into 7 bytes of <span class="org-string">"compressed"</span> data.
  //
  // This last factor dominates the blowup, so the final estimate is:
  return 32 + source_len + source_len/6;
}
</pre>


</div>

</div>

<div id="outline-container-1-3-7" class="outline-4">
<h4 id="sec-1-3-7"><span class="section-number-4">1.3.7</span> IncrementalCopy</h4>
<div class="outline-text-4" id="text-1-3-7">

<p>首先看看IncrementalCopy的原型和语义是什么
</p>


<pre class="src src-C++">// Copy <span class="org-string">"len"</span> bytes from <span class="org-string">"src"</span> to <span class="org-string">"op"</span>, one byte at a time.  Used for
// handling COPY operations where the input and output regions may
// overlap.  For example, suppose:
//    src    == <span class="org-string">"ab"</span>
//    op     == src + 2
//    len    == 20
// After IncrementalCopy(src, op, len), the result will have
// eleven copies of <span class="org-string">"ab"</span>
//    ababababababababababab
// Note that this does not match the semantics of either memcpy()
// or memmove();
static inline void IncrementalCopy(const char* src, char* op, int len) {
  DCHECK_GT(len, 0);
  do {
    *op++ = *src++;
  } while (--len &gt; 0);
}
</pre>

<p>
将src内容逐个copy到op上面去。但是注意这里必须是逐个copy到op上面去。因为src和op非常有可能重叠。
可能op后面的部分字节依赖于op前面部分的字节。这个语义必须清晰，和memcpy和memmove都是不同的。
简单的实现和上面一样逐个字节进行copy.这个在解压缩的时候非常有用，因为我们的literal已经解出来放在outputle，
而copy很可能和literal重叠，需要这种IncrementalCopy的实现。
</p>
<p>
但是是否有办法更快呢？下面就是一个更快的实现。首先我们是的op和src的差距拉到&gt;=8,一旦这样之后的话
就可以开始使用8个字节进行copy了。为了将差距拉到8，不断地做8个字节copy并且调整dest.
</p>


<pre class="src src-C++">const int kMaxIncrementCopyOverflow = 10;

static inline void IncrementalCopyFastPath(const char* src, char* op, int len) {
  while (op - src &lt; 8) {
    UNALIGNED_STORE64(op, UNALIGNED_LOAD64(src));
    len -= op - src;
    op += op - src;
  }
  while (len &gt; 0) {
    UNALIGNED_STORE64(op, UNALIGNED_LOAD64(src));
    src += 8;
    op += 8;
    len -= 8;
  }
}
</pre>

<p>
可能阅读这个代码比较难理解，作者良好的注释又有帮助了。
</p>


<pre class="src src-C++">// Equivalent to IncrementalCopy except that it can write up to ten extra
// bytes after the end of the copy, and that it is faster.
//
// The main part of this loop is a simple copy of eight bytes at a time until
// we've copied (at least) the requested amount of bytes.  However, if op and
// src are less than eight bytes apart (indicating a repeating pattern of
// length &lt; 8), we first need to expand the pattern in order to get the correct
// results. For instance, if the buffer looks like this, with the eight-byte
// &lt;src&gt; and &lt;op&gt; patterns marked as intervals:
//
//    abxxxxxxxxxxxx
//    [------]           src
//      [------]         op
//
// a single eight-byte copy from &lt;src&gt; to &lt;op&gt; will repeat the pattern once,
// after which we can move &lt;op&gt; two bytes without moving &lt;src&gt;:
//
//    ababxxxxxxxxxx
//    [------]           src
//        [------]       op
//
// and repeat the exercise until the two no longer overlap.
//
// This allows us to do very well in the special case of one single byte
// repeated many times, without taking a big hit for more general cases.
//
// The worst case of extra writing past the end of the match occurs when
// op - src == 1 and len == 1; the last copy will read from byte positions
// [0..7] and write to [4..11], whereas it was only supposed to write to
// position 1. Thus, ten excess bytes.
</pre>

<p>
不看上面注释我们也可以知道，使用这种方式是可能存在内存重叠copy的，并且很可能会多访问最后那么几个字节。
上面注释的分析就是，如果op+length之后后面还有10个空余字节的话那么就是安全的，所以kMaxIncrementCopyOverflow==10.
在使用上的话只有发现后面空余字节超过10字节之后的话，上面的算法才是安全的。
</p>
</div>

</div>

<div id="outline-container-1-3-8" class="outline-4">
<h4 id="sec-1-3-8"><span class="section-number-4">1.3.8</span> EmitLiteral</h4>
<div class="outline-text-4" id="text-1-3-8">

<p>EmitLiteral就是输出literal.虽然从Format很直观地看出literal应该怎么输出，但是还是有技巧的。最技巧的方便就是allow_fast_path.
allow_fast_path场景是如果op后面有15个空余字节的话，那么就可以使用2个8字节copy完成。这个在CompressFragment代码里面可以看到，
应用层面上只有在确保了op后面15个空余字节才会让allow_fast_path==true.而其他逻辑的话因为就是正常的copy都走了memcpy这个分支。
</p>



<pre class="src src-C++">static inline char* EmitLiteral(char* op,
                                const char* literal,
                                int len,
                                bool allow_fast_path) {
  int n = len - 1;      // Zero-length literals are disallowed
  if (n &lt; 60) {
    // Fits in tag byte
    *op++ = LITERAL | (n &lt;&lt; 2);

    // The vast majority of copies are below 16 bytes, for which a
    // call to memcpy is overkill. This fast path can sometimes
    // copy up to 15 bytes too much, but that is okay in the
    // main loop, since we have a bit to go on for both sides:
    //
    //   - The input will always have kInputMarginBytes = 15 extra
    //     available bytes, as long as we're in the main loop, and
    //     if not, allow_fast_path = false.
    //   - The output will always have 32 spare bytes (see
    //     MaxCompressedLength).
    if (allow_fast_path &amp;&amp; len &lt;= 16) {
      UNALIGNED_STORE64(op, UNALIGNED_LOAD64(literal));
      UNALIGNED_STORE64(op + 8, UNALIGNED_LOAD64(literal + 8));
      return op + len;
    }
  } else {
    // Encode in upcoming bytes
    char* base = op;
    int count = 0;
    op++;
    while (n &gt; 0) {
      *op++ = n &amp; 0xff;
      n &gt;&gt;= 8;
      count++;
    }
    assert(count &gt;= 1);
    assert(count &lt;= 4);
    *base = LITERAL | ((59+count) &lt;&lt; 2);
  }
  memcpy(op, literal, len);
  return op + len;
}
</pre>


</div>

</div>

<div id="outline-container-1-3-9" class="outline-4">
<h4 id="sec-1-3-9"><span class="section-number-4">1.3.9</span> EmitCopy</h4>
<div class="outline-text-4" id="text-1-3-9">

<p>EmitCopy非常简单也不牵扯到数据的memcpy,只是写入(offset,length)这两个分量。但是之前说了如果length&gt;=64的话，那么是需要进行copy的切分的。
</p>


<pre class="src src-C++">static inline char* EmitCopyLessThan64(char* op, int offset, int len) {
  DCHECK_LE(len, 64);
  DCHECK_GE(len, 4);
  DCHECK_LT(offset, 65536);

  if ((len &lt; 12) &amp;&amp; (offset &lt; 2048)) {
    int len_minus_4 = len - 4;
    assert(len_minus_4 &lt; 8);            // Must fit in 3 bits
    *op++ = COPY_1_BYTE_OFFSET | ((len_minus_4) &lt;&lt; 2) | ((offset &gt;&gt; 8) &lt;&lt; 5);
    *op++ = offset &amp; 0xff;
  } else {
    *op++ = COPY_2_BYTE_OFFSET | ((len-1) &lt;&lt; 2);
    LittleEndian::Store16(op, offset);
    op += 2;
  }
  // &#36825;&#37324;&#27809;&#26377;&#22788;&#29702;offset&gt;=65536&#30340;&#26684;&#24335;&#65292;&#22240;&#20026;&#23601;&#29616;&#22312;&#23454;&#29616;&#26469;&#35828;chunk&#30340;&#22823;&#23567;&#26159;32K&#19981;&#20250;&#36896;&#25104;offset&gt;=64K&#30340;&#24773;&#20917;&#12290;
  return op;
}

static inline char* EmitCopy(char* op, int offset, int len) {
  // Emit 64 byte copies but make sure to keep at least four bytes reserved
  while (len &gt;= 68) { // &#36825;&#37324;&#24517;&#39035;&#21028;&#26029;68&#65292;&#19981;&#28982;&#22914;&#26524;len&lt;4&#32780;offset&lt;208&#30340;&#35805;&#37027;&#20040;&#27809;&#26377;&#23545;&#24212;&#30340;copy&#32534;&#30721;&#24418;&#24335;
    op = EmitCopyLessThan64(op, offset, 64);
    len -= 64;
  }

  // Emit an extra 60 byte copy if have too much data to fit in one copy
  if (len &gt; 64) {
    op = EmitCopyLessThan64(op, offset, 60);
    len -= 60;
  }

  // Emit remainder
  op = EmitCopyLessThan64(op, offset, len);
  return op;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Compress</h3>
<div class="outline-text-3" id="text-1-4">

<p>终于进行Compress正题了，看看大体框架吧。
</p>


<pre class="src src-C++">size_t Compress(Source* reader, Sink* writer) {

    // &#39318;&#20808;&#21462;&#24471;reader&#30340;&#38271;&#24230;&#36827;&#34892;&#32534;&#30721;&#25918;&#22312;&#26368;&#24320;&#22836;

    size_t written = 0;
    int N = reader-&gt;Available();
    char ulength[Varint::kMax32];
    char* dest= writer-&gt;GetAppendBuffer(Varint::kMax32,ulength);
    char* p = Varint::Encode32(dest,N);
    writer-&gt;Append(dest,p-dest);
    written += (p - dest);

    //
    //   size_t written = 0;
    //   int N = reader-&gt;Available();
    //   char ulength[Varint::kMax32];
    //   char* p = Varint::Encode32(ulength, N);
    //   writer-&gt;Append(ulength, p-ulength);
    //   written += (p - ulength);

  internal::WorkingMemory wmem;
  char* scratch = NULL;
  char* scratch_output = NULL;

  while (N &gt; 0) {
    // &#28982;&#21518;num_to_read&#34920;&#31034;&#26412;&#27425;&#21387;&#32553;chunk&#30340;&#22823;&#23567;

    // Get next block to compress (without copying if possible)
    size_t fragment_size;
    const char* fragment = reader-&gt;Peek(&amp;fragment_size);
    DCHECK_NE(fragment_size, 0) &lt;&lt; <span class="org-string">": premature end of input"</span>;
    const int num_to_read = min(N, kBlockSize);
    size_t bytes_read = fragment_size;

    // &#36825;&#20010;&#22320;&#26041;&#20250;&#23581;&#35797;&#21457;&#36215;&#22810;&#27425;&#35835;&#65292;&#20294;&#26159;&#23601;&#29616;&#22312;Snappy&#40664;&#35748;&#23454;&#29616;&#26469;&#35828;&#65292;&#20854;&#23454;&#23601;&#26159;&#19968;&#27493;&#21040;&#20301;&#65292;&#19981;&#20250;&#36827;&#20837;else&#36923;&#36753;
    // &#20294;&#26159;&#21363;&#20351;&#36827;&#20837;&#19979;&#38754;&#36923;&#36753;&#20063;&#38750;&#24120;&#31616;&#21333;&#65292;&#26080;&#38750;&#23601;&#26159;&#22810;&#27425;&#21457;&#36215;&#35835;&#28982;&#21518;&#25918;&#22312;scratch&#20869;&#23384;&#37324;&#38754;
    // &#20986;&#36825;&#20010;&#21028;&#26029;&#20043;&#21518;&#65292;&#22320;&#22336;&#21644;&#22823;&#23567;&#25918;&#22312;&#20102;fragment,fragment_size&#37324;&#38754;&#12290;

    int pending_advance = 0;
    if (bytes_read &gt;= num_to_read) {
      // Buffer returned by reader is large enough
      pending_advance = num_to_read;
      fragment_size = num_to_read;
    } else {
      // Read into scratch buffer
      if (scratch == NULL) {
        // If this is the last iteration, we want to allocate N bytes
        // of space, otherwise the max possible kBlockSize space.
        // num_to_read contains exactly the correct value
        scratch = new char[num_to_read];
      }
      memcpy(scratch, fragment, bytes_read);
      reader-&gt;Skip(bytes_read);

      while (bytes_read &lt; num_to_read) {
        fragment = reader-&gt;Peek(&amp;fragment_size);
        size_t n = min&lt;size_t&gt;(fragment_size, num_to_read - bytes_read);
        memcpy(scratch + bytes_read, fragment, n);
        bytes_read += n;
        reader-&gt;Skip(n);
      }
      DCHECK_EQ(bytes_read, num_to_read);
      fragment = scratch;
      fragment_size = num_to_read;
    }
    DCHECK_EQ(fragment_size, num_to_read);

    // &#20934;&#22791;&#38024;&#23545;fragment&#26469;&#36827;&#34892;&#21387;&#32553;&#65292;&#39318;&#20808;&#25105;&#20204;&#21019;&#24314;&#19968;&#20010;hashtable
    // Get encoding table for compression
    int table_size;
    uint16* table = wmem.GetHashTable(num_to_read, &amp;table_size);

    // &#38024;&#23545;&#36825;&#27425;&#21387;&#32553;&#30340;&#35805;&#65292;&#20020;&#26102;&#31354;&#38388;&#21040;&#24213;&#24212;&#35813;&#24320;&#36767;&#22810;&#22823;&#12290;
    // Compress input_fragment and append to dest
    const int max_output = MaxCompressedLength(num_to_read);

    // Need a scratch buffer for the output, in case the byte sink doesn't
    // have room for us directly.
    if (scratch_output == NULL) {
      scratch_output = new char[max_output];
    } else {
      // Since we encode kBlockSize regions followed by a region
      // which is &lt;= kBlockSize in length, a previously allocated
      // scratch_output[] region is big enough for this iteration.
    }
    // &#35843;&#29992;CompressFragment&#26469;&#21387;&#32553;&#36825;&#20010;fragment
    char* dest = writer-&gt;GetAppendBuffer(max_output, scratch_output);
    char* end = internal::CompressFragment(fragment, fragment_size,
                                           dest, table, table_size);
    writer-&gt;Append(dest, end - dest);
    written += (end - dest);

    N -= num_to_read;
    reader-&gt;Skip(pending_advance);
  }

  delete[] scratch;
  delete[] scratch_output;

  return written;
}
</pre>


<p>
整个过程并不是很麻烦，无非就是切出chunk出来并且初始化hashtable然后交给CompressFragment来处理。
</p>


<pre class="src src-C++">char* CompressFragment(const char* const input,
                       const size_t input_size,
                       char* op,
                       uint16* table,
                       const int table_size) {
  // <span class="org-string">"ip"</span> is the input pointer, and <span class="org-string">"op"</span> is the output pointer.
  const char* ip = input;
  CHECK_LE(input_size, kBlockSize);
  CHECK_EQ(table_size &amp; (table_size - 1), 0) &lt;&lt; <span class="org-string">": table must be power of two"</span>;
  const int shift = 32 - Bits::Log2Floor(table_size);
  DCHECK_EQ(kuint32max &gt;&gt; shift, table_size - 1);
  const char* ip_end = input + input_size;
  const char* base_ip = ip;
  // Bytes in [next_emit, ip) will be emitted as literal bytes.  Or
  // [next_emit, ip_end) after the main loop.
  const char* next_emit = ip;

  // &#22238;&#24819;&#19968;&#19979;&#25105;&#20204;&#20043;&#21069;EmitLiteral&#24517;&#39035;&#30830;&#20445;15&#20010;&#23383;&#33410;&#25165;&#26377;allow_fast_path
  // &#22914;&#26524;&#25105;&#20204;&#30830;&#20445;&#26368;&#21518;15&#20010;&#23383;&#33410;&#36827;&#34892;literal&#30340;&#35805;&#65292;&#37027;&#20040;op&#21518;&#38754;&#24517;&#39035;&#23384;&#22312;&gt;=15&#23383;&#33410;
  // &#36825;&#26679;&#21069;&#38754;&#36827;&#34892;EmitLiteral&#37117;&#21487;&#20197;&#36827;&#34892;allow_fast_path&#20102;&#12290;

  const int kInputMarginBytes = 15;
  if (PREDICT_TRUE(input_size &gt;= kInputMarginBytes)) {
    const char* ip_limit = input + input_size - kInputMarginBytes;

    for (uint32 next_hash = Hash(++ip, shift); ; ) {
      DCHECK_LT(next_emit, ip);
      // The body of this loop calls EmitLiteral once and then EmitCopy one or
      // more times.  (The exception is that when we're close to exhausting
      // the input we goto emit_remainder.)
      //
      // In the first iteration of this loop we're just starting, so
      // there's nothing to copy, so calling EmitLiteral once is
      // necessary.  And we only start a new iteration when the
      // current iteration has determined that a call to EmitLiteral will
      // precede the next call to EmitCopy (if any).
      //
      // Step 1: Scan forward in the input looking for a 4-byte-long match.
      // If we get close to exhausting the input then goto emit_remainder.
      //
      // Heuristic match skipping: If 32 bytes are scanned with no matches
      // found, start looking only at every other byte. If 32 more bytes are
      // scanned, look at every third byte, etc.. When a match is found,
      // immediately go back to looking at every byte. This is a small loss
      // (~5% performance, ~0.1% density) for compressible data due to more
      // bookkeeping, but for non-compressible data (such as JPEG) it's a huge
      // win since the compressor quickly <span class="org-string">"realizes"</span> the data is incompressible
      // and doesn't bother looking for matches everywhere.
      //
      // The <span class="org-string">"skip"</span> variable keeps track of how many bytes there are since the
      // last match; dividing it by 32 (ie. right-shifting by five) gives the
      // number of bytes to move ahead for each iteration.
      uint32 skip = 32;

      // &#25105;&#20204;&#39318;&#20808;&#26597;&#25214;4bytes&#30340;match
      // &#36825;&#37324;hash==Hash(Load32(ip)),&#28982;&#21518;table[hash]=ip-base_ip.
      // &#25152;&#20197;&#26742;&#37324;&#38754;&#30340;&#20869;&#23481;&#23601;&#26159;&#30456;&#23545;&#20110;base_ip&#20063;&#23601;&#26159;&#36215;&#22987;&#36755;&#20837;&#30340;&#20559;&#31227;

      // &#22914;&#26524;&#38656;&#35201;&#29992;&#34920;&#36798;&#26159;&#34920;&#26126;&#30340;&#35805;
      // table[Hash(Load32(ip))]=ip-base_ip
      // &#36825;&#26679;&#25105;&#20204;&#21487;&#20197;&#36890;&#36807;&#39318;&#20808;&#21305;&#37197;hash&#65292;&#19968;&#26086;hash&#21305;&#37197;&#19978;&#28982;&#21518;&#26816;&#26597;&#20869;&#23481;&#26159;&#21542;&#30456;&#21516;&#26469;&#21457;&#29616;match
      // &#27880;&#24847;&#36825;&#37324;&#22914;&#26524;&#20986;&#29616;hash&#20914;&#31361;&#30340;&#35805;&#37027;&#20040;table&#26159;&#19981;&#26029;update&#30340;

      // &#21478;&#22806;&#19968;&#20010;&#26377;&#36259;&#30340;&#20107;&#24773;&#23601;&#26159;&#36825;&#20010;skip
      // &#21487;&#20197;&#30475;&#21040;&#21069;&#38754;32&#27425;&#37117;&#26159;&#25353;&#29031;1&#20010;&#23383;&#33410;&#36339;&#36291;&#65292;&#30452;&#21040;skip==64
      // &#28982;&#21518;&#25353;&#29031;2&#20010;&#23383;&#33410;&#36339;&#36291;&#65292;&#30452;&#21040;skip==128
      // &#36825;&#26159;&#19968;&#31181;&#21551;&#21457;&#26159;&#30340;&#21305;&#37197;&#31639;&#27861;
      const char* next_ip = ip;
      const char* candidate;
      do {
        ip = next_ip;
        uint32 hash = next_hash;
        DCHECK_EQ(hash, Hash(ip, shift));
        uint32 bytes_between_hash_lookups = skip++ &gt;&gt; 5;
        next_ip = ip + bytes_between_hash_lookups;
        if (PREDICT_FALSE(next_ip &gt; ip_limit)) {
          goto emit_remainder;
        }
        next_hash = Hash(next_ip, shift);

        candidate = base_ip + table[hash];
        DCHECK_GE(candidate, base_ip);
        DCHECK_LT(candidate, ip);

        table[hash] = ip - base_ip;
      } while (PREDICT_TRUE(UNALIGNED_LOAD32(ip) !=
                            UNALIGNED_LOAD32(candidate)));


      // &#21040;&#36825;&#20010;&#27493;&#39588;&#20043;&#21518;&#30340;&#35805;&#65292;&#37027;&#20040;ip&#21644;candidate&#23601;&#23436;&#20840;&#21305;&#37197;&#19978;&#20102;
      // &#25105;&#20204;&#21487;&#20197;&#23558;[next_emit,ip-1]&#20316;&#20026;literal&#36755;&#20986;

      // Step 2: A 4-byte match has been found.  We'll later see if more
      // than 4 bytes match.  But, prior to the match, input
      // bytes [next_emit, ip) are unmatched.  Emit them as <span class="org-string">"literal bytes."</span>
      DCHECK_LE(next_emit + 16, ip_end); // including margin bytes.
      op = EmitLiteral(op, next_emit, ip - next_emit, true);

      // &#28982;&#21518;&#25105;&#20204;&#36827;&#34892;copy&#36755;&#20986;

      // Step 3: Call EmitCopy, and then see if another EmitCopy could
      // be our next move.  Repeat until we find no match for the
      // input immediately after what was consumed by the last EmitCopy call.
      //
      // If we exit this loop normally then we need to call EmitLiteral next,
      // though we don't yet know how big the literal will be.  We handle that
      // by proceeding to the next iteration of the main loop.  We also can exit
      // this loop via goto if we get close to exhausting the input.
      uint64 input_bytes = 0;
      uint32 candidate_bytes = 0;

      do {
        // We have a 4-byte match at ip, and no need to emit any
        // <span class="org-string">"literal bytes"</span> prior to ip.
        const char* base = ip;

        // &#22914;&#26524;ip&#21644;candidate&#21305;&#37197;&#30340;&#35805;&#65292;&#37027;&#20040;&#23581;&#35797;&#21462;&#21457;&#29616;&#26356;&#38271;&#30340;copy

        int matched = 4 + FindMatchLength(candidate + 4, ip + 4, ip_end);
        ip += matched;
        int offset = base - candidate;
        DCHECK_EQ(0, memcmp(base, candidate, matched));
        op = EmitCopy(op, offset, matched);

        // &#21518;&#38754;&#26159;&#31639;&#27861;&#30340;&#20248;&#21270;&#65292;&#26356;&#26032;&#19968;&#19979;Hash(ip-1),&#28982;&#21518;&#30475;&#30475;&#21518;&#38754;ip&#26159;&#21542;&#31435;&#21051;&#26377;candidate&#21305;&#37197;
        // We could immediately start working at ip now, but to improve
        // compression we first update table[Hash(ip - 1, ...)].
        const char* insert_tail = ip - 1;
        next_emit = ip;
        if (PREDICT_FALSE(ip &gt;= ip_limit)) {
          goto emit_remainder;
        }
        input_bytes = UNALIGNED_LOAD64(insert_tail);
        uint32 prev_hash = HashBytes(GetUint32AtOffset(input_bytes, 0), shift);
        table[prev_hash] = ip - base_ip - 1;
        uint32 cur_hash = HashBytes(GetUint32AtOffset(input_bytes, 1), shift);
        candidate = base_ip + table[cur_hash];
        candidate_bytes = UNALIGNED_LOAD32(candidate);
        table[cur_hash] = ip - base_ip;
      } while (GetUint32AtOffset(input_bytes, 1) == candidate_bytes);

      next_hash = HashBytes(GetUint32AtOffset(input_bytes, 2), shift);
      ++ip;
    }
  }

  // &#22914;&#26524;&#26368;&#21518;&#37096;&#20998;&#27809;&#26377;&gt;=15&#20010;&#23383;&#33410;&#30340;&#35805;&#65292;&#37027;&#20040;&#23601;&#30452;&#25509;&#20316;&#20026;literal&#36755;&#20986;&#65292;&#20294;&#26159;&#32943;&#23450;&#19981;&#33021;&#22815;allow_fast_path
 emit_remainder:
  // Emit the remaining bytes as a literal
  if (next_emit &lt; ip_end) {
    op = EmitLiteral(op, next_emit, ip_end - next_emit, false);
  }

  return op;
}

</pre>


</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Uncompress</h3>
<div class="outline-text-3" id="text-1-5">

<p>Uncompress最终走到的逻辑是下面这个代码。比较重要的就是SnappyDecompressor以及Write这个接口。不过从代码逻辑上看非常简单，
首先ReadUncompressedLength，然后writer设置最终解码之后应该多大。然后decompressor开始分析各个tag了。最后decompressor判断是否读完以及
writer判断自己解码之后长度和uncompressed_len是否相同。
</p>


<pre class="src src-C++">template &lt;typename Writer&gt;
static bool InternalUncompress(Source* r,
                               Writer* writer,
                               uint32 max_len) {
  // Read the uncompressed length from the front of the compressed input
  SnappyDecompressor decompressor(r);
  uint32 uncompressed_len = 0;
  if (!decompressor.ReadUncompressedLength(&amp;uncompressed_len)) return false;
  // Protect against possible DoS attack
  if (static_cast&lt;uint64&gt;(uncompressed_len) &gt; max_len) {
    return false;
  }

  writer-&gt;SetExpectedLength(uncompressed_len);

  // Process the entire input
  decompressor.DecompressAllTags(writer);
  return (decompressor.eof() &amp;&amp; writer-&gt;CheckLength());
}
</pre>



</div>

<div id="outline-container-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> Writer</h4>
<div class="outline-text-4" id="text-1-5-1">

<p>我们首先看看一个实现SnappyArrayWriter.最关键的两个函数就是Append(copy literal)以及AppendFromSelf(copy copy).
然后对于SnappyDecompressor分析出literal以及copy之后就可以调用这两个函数来进行解压缩了。
</p>


<pre class="src src-C++">class SnappyArrayWriter {
 private:
  char* base_; // &#36215;&#22987;&#22320;&#22336;
  char* op_;  // &#24403;&#21069;&#25805;&#20316;&#22320;&#22336;
  char* op_limit_; // &#24403;&#21069;&#25805;&#20316;&#38408;&#20540;

 public:
  inline explicit SnappyArrayWriter(char* dst)
      : base_(dst),
        op_(dst) {
  }

  inline void SetExpectedLength(size_t len) {
    op_limit_ = op_ + len; // &#35774;&#32622;&#38408;&#20540;
  }

  inline bool CheckLength() const {
    return op_ == op_limit_; // &#21028;&#26029;&#38271;&#24230;&#26159;&#21542;&#21305;&#37197;
  }

  inline bool Append(const char* ip, uint32 len, bool allow_fast_path) {
    char* op = op_;
    const int space_left = op_limit_ - op;
    if (allow_fast_path &amp;&amp; len &lt;= 16 &amp;&amp; space_left &gt;= 16) {
      // Fast path, used for the majority (about 90%) of dynamic invocations.
      UNALIGNED_STORE64(op, UNALIGNED_LOAD64(ip));
      UNALIGNED_STORE64(op + 8, UNALIGNED_LOAD64(ip + 8));
    } else {
      if (space_left &lt; len) {
        return false;
      }
      memcpy(op, ip, len);
    }
    op_ = op + len;
    return true;
  }

  inline bool AppendFromSelf(uint32 offset, uint32 len) { // &#20174;&#33258;&#36523;&#22797;&#21046;&#65292;&#21521;&#21069;&#36208;offset&#28982;&#21518;copy len&#20010;&#23383;&#33410;&#25968;&#25454;
    char* op = op_;
    const int space_left = op_limit_ - op;

    if (op - base_ &lt;= offset - 1u) {  // -1u catches offset==0
      return false;
    }
    if (len &lt;= 16 &amp;&amp; offset &gt;= 8 &amp;&amp; space_left &gt;= 16) { // &#21482;&#26377;offset&gt;=8&#25165;&#21487;&#20197;&#30452;&#25509;&#25805;&#20316;
      // Fast path, used for the majority (70-80%) of dynamic invocations.
      UNALIGNED_STORE64(op, UNALIGNED_LOAD64(op - offset));
      UNALIGNED_STORE64(op + 8, UNALIGNED_LOAD64(op - offset + 8));
    } else {
      if (space_left &gt;= len + kMaxIncrementCopyOverflow) { // &#22914;&#26524;&#20801;&#35768;FastPath&#30340;&#35805;
        IncrementalCopyFastPath(op - offset, op, len);
      } else {
        if (space_left &lt; len) {
          return false;
        }
        IncrementalCopy(op - offset, op, len);
      }
    }

    op_ = op + len;
    return true;
  }
};
</pre>


<p>
不难想到如果修改一下这个实现的话那么可以做检查器，我们只是验证压缩包是否正确。
</p>


<pre class="src src-C++">// A Writer that drops everything on the floor and just does validation
class SnappyDecompressionValidator {
 private:
  size_t expected_;
  size_t produced_;

 public:
  inline SnappyDecompressionValidator() : produced_(0) { }
  inline void SetExpectedLength(size_t len) {
    expected_ = len;
  }
  inline bool CheckLength() const {
    return expected_ == produced_;
  }
  inline bool Append(const char* ip, uint32 len, bool allow_fast_path) {
    produced_ += len;
    return produced_ &lt;= expected_;
  }
  inline bool AppendFromSelf(uint32 offset, uint32 len) {
    if (produced_ &lt;= offset - 1u) return false;  // -1u catches offset==0
    produced_ += len;
    return produced_ &lt;= expected_;
  }
};
</pre>


</div>

</div>

<div id="outline-container-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> SnappyDecompressor</h4>
<div class="outline-text-4" id="text-1-5-2">

<p>SnappyDecompressor有几个比较重要的方法：
</p><ul>
<li>ReadUncompressedLength.这个就是解压缩开头的Varint.这个没有太大的问题。
</li>
<li>DecompressAllTags.这个是解压缩所有的tag，源是RefillTag填充的scratch[].
</li>
<li>RefillTag.填充tag所需要的字节到scratch[]内部。这个也没有太大问题。
</li>
</ul>

<p>在看这个代码之前，我们想想如果我们得到scratch之后应该如何从中提取tag信息呢？最好的方式就是打表。
因为tag的头一个字节反应了这个tag所有信息，所以在snappy里面有char_table这个表以头一个字节内容作为索引
</p>


<pre class="src src-C++">// Data stored per entry in lookup table:
//      Range   Bits-used       Description
//      ------------------------------------
//      1..64   0..7            Literal/copy length encoded in opcode byte
//      0..7    8..10           Copy offset encoded in opcode byte / 256
//      0..4    11..13          Extra bytes after opcode
//
// We use eight bits for the length even though 7 would have sufficed
// because of efficiency reasons:
//      (1) Extracting a byte is faster than a bit-field
//      (2) It properly aligns copy offset so we do not need a &lt;&lt;8
static const uint16 char_table[256] = {
  0x0001, 0x0804, 0x1001, 0x2001, 0x0002, 0x0805, 0x1002, 0x2002,
  0x0003, 0x0806, 0x1003, 0x2003, 0x0004, 0x0807, 0x1004, 0x2004,
  // ...
};
</pre>

<p>
这个表是可以计算出来的
</p><ul>
<li>[0..7]表示literal/copy长度,因为不管是literal/copy长度。对于copy是足够的，但是对于literal来说的话能够根据高extra byte判断后面剩余长度字节。
</li>
<li>[8..10]表示copy的offset / 256,对于offset剩余内容通过extra表示
</li>
<li>[11..13]表示后面剩余多少个字节。通过wordmask来提取。
</li>
</ul>

<p>这里workmask
</p>


<pre class="src src-C++">static const uint32 wordmask[] = {
  0u, 0xffu, 0xffffu, 0xffffffu, 0xffffffffu
};
</pre>

<p>
这样如果extra bytes==1的话，通过&amp; 0xffu可以取到1个字节。这个在代码里面就会有体现。非常精巧。
</p>
<p>
我们看看DecompressAllTags这个函数实现
</p>


<pre class="src src-C++">// Process the next item found in the input.
// Returns true if successful, false on error or end of input.
template &lt;class Writer&gt;
void DecompressAllTags(Writer* writer) {
  const char* ip = ip_;
  for ( ;; ) {
    if (ip_limit_ - ip &lt; 5) { // &#22914;&#26524;&#19981;&#22815;5&#20010;&#23383;&#33410;&#30340;&#35805;&#37027;&#20040;&#23601;&#22635;&#20805;&#65292;&#20294;&#26159;&#22635;&#20805;&#32467;&#26524;&#19981;&#19968;&#23450;&#36798;&#21040;5&#20010;&#23383;&#33410;&#12290;
      ip_ = ip;
      if (!RefillTag()) return;
      ip = ip_;
    }

    // &#35835;&#21462;tag&#31532;&#19968;&#20010;&#23383;&#33410;&#21040;c,&#24471;&#21040;entry
    const unsigned char c = *(reinterpret_cast&lt;const unsigned char*&gt;(ip++));
    const uint32 entry = char_table[c];
    // &#25105;&#20204;&#23558;extra bytes&#25353;&#29031;uint32&#36733;&#20837;&#65292;&#28982;&#21518;&#26681;&#25454;wordmask&#30693;&#36947;&#65292;&#38500;&#20102;&#30041;&#22312;c&#37324;&#38754;&#30340;&#38271;&#24230;&#20449;&#24687;&#20043;&#22806;&#65292;&#23384;&#25918;&#22312;extra bytes&#37324;&#38754;&#30340;&#38271;&#24230;&#20449;&#24687;&#65292;&#21483;&#20570;trailer.
    const uint32 trailer = LittleEndian::Load32(ip) &amp; wordmask[entry &gt;&gt; 11];
    // ip&#21518;&#38754;extra bytes&#36339;&#36807;
    ip += entry &gt;&gt; 11;
    // &#24471;&#21040;&#25918;&#22312;c&#37324;&#38754;&#30340;&#38271;&#24230;&#20449;&#24687;
    const uint32 length = entry &amp; 0xff;

    // &#22914;&#26524;&#36825;&#20010;tag&#26159;LITERAL&#30340;&#35805;
    if ((c &amp; 0x3) == LITERAL) {
      uint32 literal_length = length + trailer; // &#37027;&#20040;trailer&#34920;&#31034;literal_length&#37096;&#20998;
      // &#21518;&#38754;&#25805;&#20316;&#23601;&#26159;&#20889;&#20837;LITERAL
      uint32 avail = ip_limit_ - ip;
      while (avail &lt; literal_length) {
        bool allow_fast_path = (avail &gt;= 16);
        if (!writer-&gt;Append(ip, avail, allow_fast_path)) return;
        literal_length -= avail;
        reader_-&gt;Skip(peeked_);
        size_t n;
        ip = reader_-&gt;Peek(&amp;n);
        avail = n;
        peeked_ = avail;
        if (avail == 0) return;  // Premature end of input
        ip_limit_ = ip + avail;
      }
      bool allow_fast_path = (avail &gt;= 16);
      if (!writer-&gt;Append(ip, literal_length, allow_fast_path)) {
        return;
      }
      ip += literal_length;
    } else {
      // &#22914;&#26524;&#26159;COPY&#30340;&#35805;
      // copy_offset/256 is encoded in bits 8..10.  By just fetching
      // those bits, we get copy_offset (since the bit-field starts at
      // bit 8).
        const uint32 copy_offset = (entry &amp; 0x700) ; // &#27880;&#24847;&#36825;&#20010;&#22320;&#26041;&#24050;&#32463; * 256&#20102;&#65292;&#25105;&#20204;&#19981;&#38656;&#35201;&#36827;&#34892;&#20219;&#20309;&#25805;&#20316;
       // &#22238;&#24518;COPY(01)&#30340;(offset &gt;&gt; 8) &lt;&lt; 5.&#25152;&#20197;&#36825;&#20010;&#22320;&#26041;&#30452;&#25509;&#23601;&#26159;&#36825;&#20010;&#32467;&#26524;
       // &#22914;&#26524;&#26159;copy&#30340;&#35805;&#65292;&#37027;&#20040;trailer&#20449;&#24687;&#26159;offset&#32780;&#19981;&#26159;length
       // &#28982;&#21518;&#23558;COPY&#20889;&#20837;.
      if (!writer-&gt;AppendFromSelf(copy_offset + trailer, length)) {
        return;
      }
    }
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Example</h3>
<div class="outline-text-3" id="text-1-6">

<p>工作很简单，首先从main.cc里面读取内容然后压缩到main.cc.compress文件里面，然后读取出来解压缩对比是否正确。这里我们演示了Sink如何封装。
</p>


<pre class="src src-C++">#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

#include &lt;snappy.h&gt;
#include &lt;snappy-sinksource.h&gt;

static const char* IN_NAME=<span class="org-string">"./main.cc"</span>;
static const char* OUT_NAME=<span class="org-string">"./main.cc.compress"</span>;

class FileSink:public snappy::Sink{
  public:
    FileSink(int fd):fd_(fd){
    }
    virtual ~FileSink(){}
    virtual char* GetAppendBuffer(size_t length,char* scratch){
        return scratch;
    }
    virtual void Append(const char* bytes,size_t n){
        write(fd_,bytes,n);
    }
  private:
    int fd_;
};

int main(){
    struct stat stbuf;
    stat(IN_NAME,&amp;stbuf);
    size_t in_fsize=stbuf.st_size;
    size_t compress_fsize=0;

    // do comress
    char* in_buf=new char[in_fsize];
    {
        FILE* fin=fopen(IN_NAME,<span class="org-string">"rb"</span>);
        fread(in_buf,1,in_fsize,fin);
        fclose(fin);
        snappy::ByteArraySource source(in_buf,in_fsize);

        int fd=open(OUT_NAME,O_CREAT | O_WRONLY,0666);
        FileSink sink(fd);
        compress_fsize=snappy::Compress(&amp;source,&amp;sink);
        close(fd);
    }

    // do decompress
    stat(OUT_NAME,&amp;stbuf);
    size_t out_fsize=stbuf.st_size;
    assert(out_fsize==compress_fsize);
    char* out_buf=new char[out_fsize];
    std::string out;
    {
        FILE* fin=fopen(OUT_NAME,<span class="org-string">"rb"</span>);
        fread(out_buf,1,out_fsize,fin);
        fclose(fin);
        assert(snappy::Uncompress(out_buf,out_fsize,&amp;out)==true);
    }

    // do validate
    assert(out.size()==in_fsize);
    assert(memcmp(out.data(),in_buf,in_fsize)==0);
    delete [] in_buf;
    delete [] out_buf;
    return 0;
}
</pre>

</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-01-02T19:56+0800</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.2 with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
<!-- Baidu Analytics BEGIN --><script type="text/javascript">var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F54a700ad7035f6e485eaf2300641e7e9' type='text/javascript'%3E%3C/script%3E"));</script><!-- Baidu Analytics END --><!-- Google Analytics BEGIN --><!-- <script type="text/javascript">  var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-31377772-1']);  _gaq.push(['_trackPageview']);  (function() {    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);  })();</script> --><!-- Google Analytics END --><!-- Baidu Button BEGIN --><!-- <script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6762177" ></script><script type="text/javascript" id="bdshell_js"></script><script type="text/javascript"> document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)</script> --><!-- Baidu Button END --><!-- G+ BEGIN --><!-- Place this render call where appropriate --><!-- <script type="text/javascript">  (function() {    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;    po.src = 'https://apis.google.com/js/plusone.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);  })();</script> --><!-- G+ END --><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * *//* required: replace example with your forum shortname  */var disqus_shortname = 'feiskyblog';var disqus_identifier = 'snappy.html';var disqus_title = 'snappy.html';var disqus_url = 'http://blog.com/snappy.html';/* * * DON'T EDIT BELOW THIS LINE * * */(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><!-- DISQUS END --></body>
</html>
